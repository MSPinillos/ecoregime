[{"path":"https://mspinillos.github.io/ecoregime/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 2, June 1991Copyright © 1989, 1991 Free Software Foundation, Inc.,51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://mspinillos.github.io/ecoregime/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"licenses software designed take away freedom share change . contrast, GNU General Public License intended guarantee freedom share change free software–make sure software free users. General Public License applies Free Software Foundation’s software program whose authors commit using . (Free Software Foundation software covered GNU Lesser General Public License instead.) can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge service wish), receive source code can get want , can change software use pieces new free programs; know can things. protect rights, need make restrictions forbid anyone deny rights ask surrender rights. restrictions translate certain responsibilities distribute copies software, modify . example, distribute copies program, whether gratis fee, must give recipients rights . must make sure , , receive can get source code. must show terms know rights. protect rights two steps: (1) copyright software, (2) offer license gives legal permission copy, distribute /modify software. Also, author’s protection , want make certain everyone understands warranty free software. software modified someone else passed , want recipients know original, problems introduced others reflect original authors’ reputations. Finally, free program threatened constantly software patents. wish avoid danger redistributors free program individually obtain patent licenses, effect making program proprietary. prevent , made clear patent must licensed everyone’s free use licensed . precise terms conditions copying, distribution modification follow.","code":""},{"path":"https://mspinillos.github.io/ecoregime/LICENSE.html","id":"terms-and-conditions-for-copying-distribution-and-modification","dir":"","previous_headings":"","what":"TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION","title":"GNU General Public License","text":"0. License applies program work contains notice placed copyright holder saying may distributed terms General Public License. “Program”, , refers program work, “work based Program” means either Program derivative work copyright law: say, work containing Program portion , either verbatim modifications /translated another language. (Hereinafter, translation included without limitation term “modification”.) licensee addressed “”. Activities copying, distribution modification covered License; outside scope. act running Program restricted, output Program covered contents constitute work based Program (independent made running Program). Whether true depends Program . 1. may copy distribute verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice disclaimer warranty; keep intact notices refer License absence warranty; give recipients Program copy License along Program. may charge fee physical act transferring copy, may option offer warranty protection exchange fee. 2. may modify copy copies Program portion , thus forming work based Program, copy distribute modifications work terms Section 1 , provided also meet conditions: ) must cause modified files carry prominent notices stating changed files date change. b) must cause work distribute publish, whole part contains derived Program part thereof, licensed whole charge third parties terms License. c) modified program normally reads commands interactively run, must cause , started running interactive use ordinary way, print display announcement including appropriate copyright notice notice warranty (else, saying provide warranty) users may redistribute program conditions, telling user view copy License. (Exception: Program interactive normally print announcement, work based Program required print announcement.) requirements apply modified work whole. identifiable sections work derived Program, can reasonably considered independent separate works , License, terms, apply sections distribute separate works. distribute sections part whole work based Program, distribution whole must terms License, whose permissions licensees extend entire whole, thus every part regardless wrote . Thus, intent section claim rights contest rights work written entirely ; rather, intent exercise right control distribution derivative collective works based Program. addition, mere aggregation another work based Program Program (work based Program) volume storage distribution medium bring work scope License. 3. may copy distribute Program (work based , Section 2) object code executable form terms Sections 1 2 provided also one following: ) Accompany complete corresponding machine-readable source code, must distributed terms Sections 1 2 medium customarily used software interchange; , b) Accompany written offer, valid least three years, give third party, charge cost physically performing source distribution, complete machine-readable copy corresponding source code, distributed terms Sections 1 2 medium customarily used software interchange; , c) Accompany information received offer distribute corresponding source code. (alternative allowed noncommercial distribution received program object code executable form offer, accord Subsection b .) source code work means preferred form work making modifications . executable work, complete source code means source code modules contains, plus associated interface definition files, plus scripts used control compilation installation executable. However, special exception, source code distributed need include anything normally distributed (either source binary form) major components (compiler, kernel, ) operating system executable runs, unless component accompanies executable. distribution executable object code made offering access copy designated place, offering equivalent access copy source code place counts distribution source code, even though third parties compelled copy source along object code. 4. may copy, modify, sublicense, distribute Program except expressly provided License. attempt otherwise copy, modify, sublicense distribute Program void, automatically terminate rights License. However, parties received copies, rights, License licenses terminated long parties remain full compliance. 5. required accept License, since signed . However, nothing else grants permission modify distribute Program derivative works. actions prohibited law accept License. Therefore, modifying distributing Program (work based Program), indicate acceptance License , terms conditions copying, distributing modifying Program works based . 6. time redistribute Program (work based Program), recipient automatically receives license original licensor copy, distribute modify Program subject terms conditions. may impose restrictions recipients’ exercise rights granted herein. responsible enforcing compliance third parties License. 7. , consequence court judgment allegation patent infringement reason (limited patent issues), conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. distribute satisfy simultaneously obligations License pertinent obligations, consequence may distribute Program . example, patent license permit royalty-free redistribution Program receive copies directly indirectly , way satisfy License refrain entirely distribution Program. portion section held invalid unenforceable particular circumstance, balance section intended apply section whole intended apply circumstances. purpose section induce infringe patents property right claims contest validity claims; section sole purpose protecting integrity free software distribution system, implemented public license practices. Many people made generous contributions wide range software distributed system reliance consistent application system; author/donor decide willing distribute software system licensee impose choice. section intended make thoroughly clear believed consequence rest License. 8. distribution /use Program restricted certain countries either patents copyrighted interfaces, original copyright holder places Program License may add explicit geographical distribution limitation excluding countries, distribution permitted among countries thus excluded. case, License incorporates limitation written body License. 9. Free Software Foundation may publish revised /new versions General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies version number License applies “later version”, option following terms conditions either version later version published Free Software Foundation. Program specify version number License, may choose version ever published Free Software Foundation. 10. wish incorporate parts Program free programs whose distribution conditions different, write author ask permission. software copyrighted Free Software Foundation, write Free Software Foundation; sometimes make exceptions . decision guided two goals preserving free status derivatives free software promoting sharing reuse software generally.","code":""},{"path":"https://mspinillos.github.io/ecoregime/LICENSE.html","id":"no-warranty","dir":"","previous_headings":"","what":"NO WARRANTY","title":"GNU General Public License","text":"11. PROGRAM LICENSED FREE CHARGE, WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION. 12. EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MAY MODIFY /REDISTRIBUTE PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES. END TERMS CONDITIONS","code":""},{"path":"https://mspinillos.github.io/ecoregime/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively convey exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program interactive, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, commands use may called something show w show c; even mouse-clicks menu items–whatever suits program. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. sample; alter names: General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. Gnomovision version 69, Copyright (C) year name of author Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'. This is free software, and you are welcome to redistribute it under certain conditions; type `show c' for details. Yoyodyne, Inc., hereby disclaims all copyright interest in the program `Gnomovision' (which makes passes at compilers) written by James Hacker.  <signature of Ty Coon>, 1 April 1989 Ty Coon, President of Vice"},{"path":[]},{"path":"https://mspinillos.github.io/ecoregime/articles/EDR_framework.html","id":"ecological-dynamic-regimes-and-the-edr-framework","dir":"Articles","previous_headings":"1. Introduction","what":"1.1. Ecological Dynamic Regimes and the EDR framework","title":"Ecological Dynamic Regime framework","text":"Ecological Dynamic Regime (EDR) defined “fluctuations ecosystem states around trend average resulting intricate mix internal processes external forces , absence perturbations, keep system within specific domains attraction” (Sánchez-Pinillos et al., 2023). EDRs composed multiple ecological trajectories showing similar processes development, interaction, reorganization state variables time. Thus, ecological trajectories essential units EDRs can defined sequences observations capturing temporal changes state variables. Usually, ecological trajectories defined based multiple state variables (e.g., species, functional traits, land uses) make challenging characterization comparison EDRs. EDR framework set algorithms metrics aiming characterize compare EDRs composed ecological trajectories multidimensional state spaces. can find information following publication, including formal definition EDR concept, methodological details framework, illustrative examples artificial real data sets: Sánchez-Pinillos M., Kéfi, S., De Cáceres, M., Dakos, V. 2023. Ecological Dynamic Regimes: Identification, characterization, comparison. Ecological Monographs. https://doi.org/10.1002/ecm.1589","code":""},{"path":"https://mspinillos.github.io/ecoregime/articles/EDR_framework.html","id":"about-this-vignette","dir":"Articles","previous_headings":"1. Introduction","what":"1.2. About this vignette","title":"Ecological Dynamic Regime framework","text":"vignette aims give overview EDR framework implementation ecoregime characterize compare EDRs. can install ecoregime directly CRAN GitHub account (development version): installed ecoregime load :","code":"# install.packages(\"ecoregime\") # devtools::install_github(repo = \"MSPinillos/ecoregime\", dependencies = T, build_vignettes = T) library(ecoregime) citation(\"ecoregime\") #> To cite 'ecoregime' in publications use: #>  #>   Sánchez-Pinillos M, Kéfi S, De Cáceres M, Dakos V (2023). \"Ecological #>   dynamic regimes: Identification, characterization, and comparison.\" #>   _Ecological Monographs_. <https://doi.org/10.1002/ecm.1589>. #>  #>   Sánchez-Pinillos M (2023). _ecoregime: Analysis of Ecological Dynamic #>   Regimes_. <https://doi.org/10.5281/zenodo.7584943>. #>  #> To see these entries in BibTeX format, use 'print(<citation>, #> bibtex=TRUE)', 'toBibtex(.)', or set #> 'options(citation.bibtex.max=999)'."},{"path":"https://mspinillos.github.io/ecoregime/articles/EDR_framework.html","id":"trajectory-data-state-and-trajectory-spaces","dir":"Articles","previous_headings":"","what":"2. Trajectory data, state and trajectory spaces","title":"Ecological Dynamic Regime framework","text":"familiar ecological trajectories defined multivariate spaces, can probably skip section. Otherwise, recommend read . Let define simple example use along vignette. Imagine 10 sampling units monitoring temporal changes state variables. example, sampling units (, B, …, J) permanent plots transects inventoried abundance two species (sp1, sp2) three temporal points (t = 1, t = 2, t = 3). use Lotka-Volterra model generate artificial data illustrate example. define parameters model generate trajectories leading competitive exclusion sp2 sp1 regardless initial state. , sampling units analogous trajectories can considered part EDR. obtain abundance matrix similar get field data. sampling unit (sampling_unit) observation (time), know relative abundance two species (sp1 sp2). Next, need define state space ecological trajectories live. state space multidimensional resemblance space defined dissimilarities every pair states (observations) terms state variables (species). , need generate matrix (\\(D_O\\)) representing state space containing dissimilarities observations sampling units. choice dissimilarity metric used generate \\(D_O\\) depends characteristics data nature variables. decision made carefully since affect analyses EDR framework. example, using species abundances. common dissimilarity metric adequate percentage difference (.k.. Bray-Curtis index). However, presence/absence data, prefer Jaccard’s distance, state variables categorical (e.g., functional traits), use multi-trait dissimilarity (e.g., Gower distance). example, use vegan calculate Bray-Curtis dissimilarities generate \\(D_O\\). can visualize state space using ordination methods. , apply multidimensional scaling (mMDS; smacof) dissimilarity matrix \\(D_O\\) plot distribution ecological states ordination space. use different colors code sampling unit represent observations sampling unit:  see ecological trajectories distributed state space, just need link states sampling unit chronological order.  trajectory space multidimensional space defined dissimilarities trajectories (.e., whole sequence states sampling unit). Analogously state space, need generate dissimilarity matrix (\\(D_T\\)) metric use affect subsequent analyses. Although multiple metrics, formal analyses evaluating performance ecological applications. , suggest directed segment path dissimilarity (De Cáceres et al., 2019, Ecol. Monogr., https://doi.org/10.1002/ecm.1350), use dissimilarity metric. contrast state space, trajectory space, trajectory represented one point:","code":"# ID of the sampling units and observations ID_sampling <- LETTERS[1:10] ID_obs <- 1:3  # Define initial species abundances set.seed(123) initial <- data.frame(sampling_units = ID_sampling,                     sp1 = round(runif(10), 2),                     sp2 = round(runif(10), 2))  # Define the parameters for the Lotka-Volterra model parms <- c(r1 = 1, r2 = 0.1, a11 = 0.02, a21 = 0.03, a22 = 0.02, a12 = 0.01)  # We can use primer and deSolve to run the simulations library(primer) #> Loading required package: deSolve #> Loading required package: ggplot2 simulated_abun <- lapply(1:nrow(initial), function(isampling){   # Initial abundance in the sampling unit i   initialN <- c(initial$sp1[isampling], initial$sp2[isampling])   # Simulate community dynamics   simulated_abun <- data.frame(ode(y = initialN, times = ID_obs, func = lvcomp2, parms = parms))   # Add the names of the sampling units   simulated_abun$sampling_unit <- ID_sampling[isampling]   # Calculate relative abundances   simulated_abun$sp1 <- simulated_abun$X1/rowSums(simulated_abun[, 2:3])   simulated_abun$sp2 <- simulated_abun$X2/rowSums(simulated_abun[, 2:3])      return(simulated_abun[, c(\"sampling_unit\", \"time\", \"sp1\", \"sp2\")]) })  # Compile species abundances of all sampling units in the same data frame abundance <- do.call(rbind, simulated_abun) head(abundance) #>   sampling_unit time       sp1        sp2 #> 1             A    1 0.2320000 0.76800000 #> 2             A    2 0.4222631 0.57773693 #> 3             A    3 0.6354107 0.36458929 #> 4             B    1 0.6370968 0.36290323 #> 5             B    2 0.8078814 0.19211857 #> 6             B    3 0.9066680 0.09333198 # Generate a matrix containing dissimilarities between states state_dissim <- vegan::vegdist(abundance[, c(\"sp1\", \"sp2\")], method = \"bray\") as.matrix(state_dissim)[1:6, 1:6] #>           1         2           3           4          5          6 #> 1 0.0000000 0.1902631 0.403410706 0.405096774 0.57588143 0.67466802 #> 2 0.1902631 0.0000000 0.213147639 0.214833707 0.38561836 0.48440495 #> 3 0.4034107 0.2131476 0.000000000 0.001686068 0.17247072 0.27125731 #> 4 0.4050968 0.2148337 0.001686068 0.000000000 0.17078465 0.26957124 #> 5 0.5758814 0.3856184 0.172470722 0.170784654 0.00000000 0.09878659 #> 6 0.6746680 0.4844050 0.271257312 0.269571243 0.09878659 0.00000000 # Multidimensional scaling state_mds <- smacof::smacofSym(state_dissim, ndim = 2) state_mds <- data.frame(state_mds$conf)  # Define different colors for each trajectory traj.colors <- RColorBrewer::brewer.pal(10, \"Paired\")  # Plot the distribution of the states in the state space plot(state_mds$D1, state_mds$D2,      col = rep(traj.colors, each = 3), # use different colors for each sampling unit      pch = rep(ID_sampling, each = 3), # use different symbols for each sampling unit      xlab = \"Axis 1\", ylab = \"Axis 2\",      main = \"State space\") ## -->> This code shows you the process step by step. You could directly use  ## -->> ecotraj::trajectoryPlot()  # Plot the distribution of the states in the state space plot(state_mds$D1, state_mds$D2,      col = rep(traj.colors, each = 3), # use different colors for each sampling unit      pch = rep(ID_sampling, each = 3), # use different symbols for each sampling unit      xlab = \"Axis 1\", ylab = \"Axis 2\",      main = \"State space\")  # Link trajectory states in chronological order for (isampling in seq(1, 30, 3)) {   # From observation 1 to observation 2   shape::Arrows(state_mds[isampling, 1], state_mds[isampling, 2],          state_mds[isampling + 1, 1], state_mds[isampling + 1, 2],          col = traj.colors[1+(isampling-1)/3], arr.adj = 1)   # From observation 2 to observation 3   shape::Arrows(state_mds[isampling + 1, 1], state_mds[isampling + 1, 2],          state_mds[isampling + 2, 1], state_mds[isampling + 2, 2],          col = traj.colors[1+(isampling-1)/3], arr.adj = 1) } # Generate a matrix containing dissimilarities between trajectories traj_dissim <- ecotraj::trajectoryDistances(state_dissim,                                              sites = rep(ID_sampling, each = 3),                                             surveys = rep(ID_obs, 10), distance.type = \"DSPD\")  as.matrix(traj_dissim)[1:6, 1:6] #>           A          B         C          D         E         F #> A 0.0000000 0.30509564 0.1084426 0.27711311 0.5425424 0.2600516 #> B 0.3050956 0.00000000 0.1409823 0.02576483 0.1520544 0.6244592 #> C 0.1084426 0.14098231 0.0000000 0.11299979 0.3784291 0.4231264 #> D 0.2771131 0.02576483 0.1129998 0.00000000 0.1756016 0.6031298 #> E 0.5425424 0.15205442 0.3784291 0.17560156 0.0000000 0.8146293 #> F 0.2600516 0.62445921 0.4231264 0.60312977 0.8146293 0.0000000 # Multidimensional scaling traj_mds <- smacof::smacofSym(traj_dissim, ndim = 2) traj_mds <- data.frame(traj_mds$conf)  # Plot the distribution of the trajectories in the trajectory space plot(traj_mds$D1, traj_mds$D2,      col = traj.colors, # use different colors for each sampling unit      pch = ID_sampling, # use different symbols for each sampling unit      xlab = \"Axis 1\", ylab = \"Axis 2\",      main = \"Trajectory space\")"},{"path":[]},{"path":"https://mspinillos.github.io/ecoregime/articles/EDR_framework.html","id":"identifying-edrs-from-clustering-analyses","dir":"Articles","previous_headings":"3. Defining EDRs","what":"3.1. Identifying EDRs from clustering analyses","title":"Ecological Dynamic Regime framework","text":"Identifying EDRs involves finding groups ecological trajectories showing dynamic patterns similar ecological trajectory trajectory space. sense, possible use trajectory dissimilarity matrix (\\(D_T\\)) identify EDRs clustering. However, applying clustering analyses trajectory data always straightforward. Depending characteristics data, goals, system evaluating, choice clustering algorithm may important consequences. Currently, scope ecoregime can find details paper introducing EDR framework (Sánchez-Pinillos et al., 2023)","code":""},{"path":"https://mspinillos.github.io/ecoregime/articles/EDR_framework.html","id":"defining-edrs-based-on-ecological-properties","dir":"Articles","previous_headings":"3. Defining EDRs","what":"3.2. Defining EDRs based on ecological properties","title":"Ecological Dynamic Regime framework","text":"Clustering analyses way define EDRs. stated , ecological trajectories simulated data can considered part EDR similar dynamic patterns. Thus, define groups trajectories want evaluate sharing similar aspects state variables. example, consider groups trajectories number observations state variables change following similar patterns.","code":""},{"path":"https://mspinillos.github.io/ecoregime/articles/EDR_framework.html","id":"representative-trajectories","dir":"Articles","previous_headings":"","what":"4. Representative trajectories","title":"Ecological Dynamic Regime framework","text":"Regardless method used define EDRs, can use ecoregime summarize dynamics. example, easy identify clear pattern competitive exclusion sp2 sp1. can simply plot changes species abundances time see pattern:  can test correlations first axis state space species abundances along trajectories. analyses fine extremely simple systems one simulated toy data. However, want apply similar approaches empirical data, finding clear dynamical patterns becomes difficult. real ecosystems, usually deal great heterogeneity, multiple variables interacting , noise. consequence, need robust tools able summarize great variety trajectories multidimensional spaces. precisely RETRA-EDR pursues.","code":"# Plot species abundances over time plot(abundance$time, abundance$sp1, type = \"n\", ylim = c(-0.01, 1),      xlab = \"Observation\", ylab = \"Species abundance\",      main = \"Temporal variation in species composition\")  for (i in seq_along(ID_sampling)) {   points(abundance[which(abundance$sampling_unit == ID_sampling[i]), ]$time,          abundance[which(abundance$sampling_unit == ID_sampling[i]), ]$sp1,          col = traj.colors[i], pch = ID_sampling[i])   lines(abundance[which(abundance$sampling_unit == ID_sampling[i]), ]$time,          abundance[which(abundance$sampling_unit == ID_sampling[i]), ]$sp1,          col = \"black\", pch = ID_sampling[i])      points(abundance[which(abundance$sampling_unit == ID_sampling[i]), ]$time,          abundance[which(abundance$sampling_unit == ID_sampling[i]), ]$sp2,          col = traj.colors[i], pch = ID_sampling[i])   lines(abundance[which(abundance$sampling_unit == ID_sampling[i]), ]$time,          abundance[which(abundance$sampling_unit == ID_sampling[i]), ]$sp2,          col = \"red\", pch = ID_sampling[i], lty = 2) }  legend(\"bottomleft\", legend = c(\"sp1\", \"sp2\"), col = 1:2, lty = 1:2, bg = \"white\") # Correlation of the first axis of the state space with the abundance of sp1 cor(state_mds$D1, abundance$sp1) #> [1] 1  # Correlation of the first axis of the state space with the abundance of sp2 cor(state_mds$D1, abundance$sp2) #> [1] -1"},{"path":"https://mspinillos.github.io/ecoregime/articles/EDR_framework.html","id":"identifying-representative-trajectories-with-retra-edr","dir":"Articles","previous_headings":"4. Representative trajectories","what":"4.1. Identifying representative trajectories with RETRA-EDR","title":"Ecological Dynamic Regime framework","text":"RETRA-EDR (REpresentative TRAjectories Ecological Dynamic Regimes) algorithm aims identify representative trajectories EDRs based distribution density ecological trajectories (Sánchez-Pinillos et al., 2023). Whereas many algorithms similar goals developed moving objects low-dimensional spaces, RETRA-EDR can applied high-dimensional spaces, capturing complexity empirical data. explain details RETRA-EDR vignette (can find Sánchez-Pinillos et al., 2023), important know main steps understand output returned retra_edr(): ecological trajectories forming EDR split segments. , segment space analogous trajectory space generated matrix containing segment dissimilarities. segment space divided regions minimum number trajectory segments (minSegs). , RETRA-EDR recursively divides space halves following axes segment space generating kd-tree structure. greater density segments particular region, larger number partitions required obtaining regions minSegs segments. number partitions known depth kd-tree (kdTree_depth) number segments final region Density. region least minSegs segments, RETRA-EDR extracts medoid representative segment. representative segments joined forming network representative trajectories. RETRA-EDR returns set attributes characterizing representative trajectories identified EDR, including value minSegs; sequence representative segments (Segments) number states (Size) forming representative trajectory; total length trajectory (Length); links (Link) generated join representative segments dissimilarity connected states (Distance); number segments region represented representative segment (Density), number partitions segment space obtaining region minSegs segments less (kdTree_depth). Let’s apply retra_edr() data. EDR contains 10 trajectories, assign value minSegs relatively low. RETRA-EDR returned two representative trajectories. can summarize attributes using summary(): output retra_edr() object class RETRA. can extract specific attributes lists. Segments probably important attribute since informs states form representative trajectories. T1 composed six states three different trajectories (B, , E). T2 composed three states sampling unit C converges towards T1 link last state C second state .","code":"# Use set.seed to obtain reproducible results of the segment space in RETRA-EDR set.seed(123)  # Apply RETRA-EDR repr_traj <- retra_edr(d = state_dissim, trajectories = rep(ID_sampling, each = 3),                    states = rep(ID_obs, 10), minSegs = 2) summary(repr_traj) #>    ID Size    Length   Avg_link   Sum_link Avg_density Max_density Avg_depth #> T1 T1    6 0.3577606 0.02996245 0.05992491           3           3  3.666667 #> T2 T2    7 0.6048257 0.03925918 0.07851836           3           3  3.500000 #>    Max_depth #> T1         4 #> T2         4 lapply(repr_traj, \"[[\", \"Segments\") #> $T1 #> [1] \"B[1-2]\" \"I[2-3]\" \"E[2-3]\" #>  #> $T2 #> [1] \"C[1-2]\" \"C[2-3]\" \"I[2-3]\" \"E[2-3]\""},{"path":"https://mspinillos.github.io/ecoregime/articles/EDR_framework.html","id":"visualizing-representative-trajectories-in-the-state-space","dir":"Articles","previous_headings":"4. Representative trajectories","what":"4.2. Visualizing representative trajectories in the state space","title":"Ecological Dynamic Regime framework","text":"can also visualize representative trajectories state space using function plot().","code":"# Plot the representative trajectories of an EDR plot(repr_traj, # <-- This is a RETRA object returned by retra_edr()      # data to generate the state space      d = state_mds, trajectories = rep(ID_sampling, each = 3), states = rep(ID_obs, 10),      # use the colors previously used for individual trajectories.       # (make them more transparent to highlight representative trajectories)      traj.colors = alpha(traj.colors, 0.3),      # display representative trajectories in blue          RT.colors = \"blue\",      # select T2 to be displayed with a different color (black)      select_RT = \"T2\", sel.color = \"black\",      # Identify artificial links using dashed lines (default) and a different color (red)      link.lty = 2, link.color = \"red\",      # We can use other arguments in plot()      main = \"Representative trajectories\")  # Add a legend legend(\"bottomright\", c(\"T1\", \"T2\", \"Link\"),         col = c(\"blue\", \"black\", \"red\"), lty = c(1, 1, 2))"},{"path":"https://mspinillos.github.io/ecoregime/articles/EDR_framework.html","id":"defining-representative-trajectories-based-on-trajectory-features","dir":"Articles","previous_headings":"4. Representative trajectories","what":"4.3. Defining representative trajectories based on trajectory features","title":"Ecological Dynamic Regime framework","text":"RETRA-EDR returns longest possible trajectory according procedure defined . However, interested fraction representative trajectory, split representative trajectories based criteria (e.g. long artificial links), maybe, define representative trajectory. Let’s say want split T1 T2 last segment (\"E[2-3]\"). , can use function define_retra(). two ways defining “new” trajectories. first one consists providing details data frame: second one consists providing list sequences segments defining trajectory. particularly useful want select subset output RETRA-EDR: case, define_retra() return output define_retra() returns object class RETRA can use plot new trajectories:","code":"# Generate a data frame indicating the states forming the new trajectories new_traj_df <- data.frame(   # name of the new trajectories (as many times as the number of states)   RT = c(rep(\"T1.1\", 4), rep(\"T2.1\", 5), rep(\"T1.2\", 2)),   # name of the trajectories (sampling units)   RT_traj = c(rep(\"B\", 2), rep(\"I\", 2), # for the first trajectory (T1.1)               rep(\"C\", 3), rep(\"I\", 2), # for the second trajectory (T2.1)               rep(\"E\", 2)), # for the third trajectory (T1.2)   # states in each sampling unit    RT_states = c(1:2, 2:3, # for the first trajectory (T1.1)                 1:3, 2:3, # for the second trajectory (T2.1)                 2:3), # for the third trajectory (T1.2)   # representative trajectories obtained in retra_edr()   RT_retra = c(rep(\"T1\", 4), rep(\"T2\", 5),                 rep(\"T1\", 2)) # The last segment belong to both (T1, T2), choose one )  new_traj_df #>      RT RT_traj RT_states RT_retra #> 1  T1.1       B         1       T1 #> 2  T1.1       B         2       T1 #> 3  T1.1       I         2       T1 #> 4  T1.1       I         3       T1 #> 5  T2.1       C         1       T2 #> 6  T2.1       C         2       T2 #> 7  T2.1       C         3       T2 #> 8  T2.1       I         2       T2 #> 9  T2.1       I         3       T2 #> 10 T1.2       E         2       T1 #> 11 T1.2       E         3       T1 # List including the sequence of segments for each new trajectory new_traj_ls <- list(   # First part of T1 excluding the last segment   repr_traj$T1$Segments[1:(length(repr_traj$T1$Segments) - 1)],   # First part of T2 excluding the last segment   repr_traj$T2$Segments[1:(length(repr_traj$T2$Segments) - 1)],   # Last segment of T1 and T2: segment composed of states 2 and 3 of the sampling unit E (\"E[2-3]\")   \"E[2-3]\" )  new_traj_ls #> [[1]] #> [1] \"B[1-2]\" \"I[2-3]\" #>  #> [[2]] #> [1] \"C[1-2]\" \"C[2-3]\" \"I[2-3]\" #>  #> [[3]] #> [1] \"E[2-3]\" # Define representative trajectories using a data frame new_repr_traj <- define_retra(data = new_traj_df,               # Information of the state space              d = state_dissim, trajectories = rep(ID_sampling, each = 3),               states = rep(ID_obs, 10),               # RETRA object returned by retra_edr()              retra = repr_traj)  # Define representative trajectories using a list with sequences of segments new_repr_traj_ls <- define_retra(data = new_traj_ls,               # Information of the state space              d = state_dissim, trajectories = rep(ID_sampling, each = 3),               states = rep(ID_obs, 10),               # RETRA object returned by retra_edr()              retra = repr_traj)  if (all.equal(new_repr_traj, new_repr_traj_ls)) {   print(\"Yes, both are equal!\") } #> [1] \"Yes, both are equal!\" plot(new_repr_traj, # <-- This is the RETRA object returned by define_retra()      # data to generate the state space      d = state_mds, trajectories = rep(ID_sampling, each = 3), states = rep(ID_obs, 10),      # display individual trajectories in light blue      traj.colors = \"lightblue\",      # display representative trajectories in dark blue          RT.colors = \"darkblue\",      # select T1.2 to be displayed in a different color (red)      select_RT = \"T1.2\", sel.color = \"red\",      # Identify artificial links using dashed lines (default), but use the same       # color than the representative trajectories (default)      link.lty = 2, link.color = NULL,      # We can use other arguments in plot()      main = \"Defined representative trajectories\")  # Add a legend  legend(\"bottomright\", c(\"T1.1, T2.1\", \"T1.2\", \"Link\"),         col = c(\"darkblue\", \"red\", \"darkblue\"), lty = c(1, 1, 2))"},{"path":"https://mspinillos.github.io/ecoregime/articles/EDR_framework.html","id":"variation-of-ecological-properties-along-representative-trajectories","dir":"Articles","previous_headings":"4. Representative trajectories","what":"4.4. Variation of ecological properties along representative trajectories","title":"Ecological Dynamic Regime framework","text":"definition representative trajectories based real states sampling units. Thus, possible assess variation ecological properties along representative trajectories, therefore, across EDR. Let’s see species diversity varies along representative trajectories returned retra_edr(). First, need calculate index species diversity (e.g., Shannon index) states representative trajectory set order states trajectory: , can evaluate variation species diversity along representative trajectories graphically:","code":"# Set an ID in the abundance matrix abundance$ID <- paste0(abundance$sampling_unit, abundance$time)  # Calculate the Shannon index in all trajectory states abundance$Shannon <- vegan::diversity(abundance[, c(\"sp1\", \"sp2\")], index = \"shannon\")  # Identify the states forming both representative trajectories traj_states <- lapply(repr_traj, function(iRT){   segments <- iRT$Segments   seg_components <- strsplit(gsub(\"\\\\]\", \"\", gsub(\"\\\\[\", \"-\", segments)), \"-\")   traj_states <- vapply(seg_components, function(iseg){     c(paste0(iseg[1], iseg[2]), paste0(iseg[1], iseg[3]))   }, character(2))   traj_states <- unique(as.character(traj_states))   traj_states <- data.frame(ID = traj_states, RT_states = 1:length(traj_states)) })  # Associate the states of the representative trajectories with their corresponding # value of the Shannnon index RT_diversity <- lapply(traj_states, function(iRT){   data <- merge(iRT, abundance, by = \"ID\", all.x = T)   data <- data[order(data$RT_states), ] })  RT_diversity$T2 #>   ID RT_states sampling_unit time       sp1        sp2    Shannon #> 1 C1         1             C    1 0.3761468 0.62385321 0.66214624 #> 2 C2         2             C    2 0.5930319 0.40696810 0.67573602 #> 3 C3         3             C    3 0.7754031 0.22459689 0.53266482 #> 6 I2         4             I    2 0.8009390 0.19906100 0.49909794 #> 7 I3         5             I    3 0.9044378 0.09556219 0.31522122 #> 4 E2         6             E    2 0.9574203 0.04257971 0.17605768 #> 5 E3         7             E    3 0.9809725 0.01902749 0.09422978 # Plot the variation of species diversity in T1 plot(x = RT_diversity$T1$RT_states + 1, y = RT_diversity$T1$Shannon,      type = \"l\", col = \"blue\", xlim = c(1, 7), ylim = c(0, 0.7),       xlab = \"RT state\", ylab = \"Shannon index\",      main = \"Variation of species diversity\") # Add the variation of species diversity in T2 lines(x = RT_diversity$T2$RT_states, y = RT_diversity$T2$Shannon,       col = \"black\") # Add a legend legend(\"topright\", c(\"T1\", \"T2\"), col = c(\"blue\", \"black\"), lty = 1)"},{"path":"https://mspinillos.github.io/ecoregime/articles/EDR_framework.html","id":"distribution-and-heterogeneity-of-ecological-trajectories-in-edrs","dir":"Articles","previous_headings":"","what":"5. Distribution and heterogeneity of ecological trajectories in EDRs","title":"Ecological Dynamic Regime framework","text":"Representative trajectories aim summarize main dynamic patterns ecological systems given EDR. complement, can compute additional metrics understand internal structure EDR.","code":""},{"path":"https://mspinillos.github.io/ecoregime/articles/EDR_framework.html","id":"dynamic-dispersion-ddis","dir":"Articles","previous_headings":"5. Distribution and heterogeneity of ecological trajectories in EDRs","what":"5.1. Dynamic dispersion (dDis)","title":"Ecological Dynamic Regime framework","text":"Dynamic dispersion (dDis) calculated average dissimilarity trajectories EDR another trajectory taken reference (Sánchez-Pinillos et al., 2023). trajectory taken reference one representative trajectories (e.g. T2), dDis can used indicator fitness data overall metric dispersion trajectories EDR. First, need prepare data. Even states representative trajectories already abundance dissimilarity matrices, need duplicate indicate different trajectory. can directly use data frame produced calculate species diversity. Now, can compute dDis using dDis(): Instead using representative trajectory reference, use trajectory EDR quantify “immersed” EDR. Let’s compare dDis trajectories sampling units , part representative trajectories, F, displayed relatively far rest trajectories state trajectory spaces. case, use trajectory dissimilarity matrix generated original data: expected, dispersion trajectory F taken reference larger trajectory , indicating F isolated within EDR. Alternatively, can weight trajectory depending criteria. Currently, dDis() able compute dDis weighting ecological trajectories size (w.type = \"size\") length (w.type = \"length\"). However, want use different criteria, can use set weights choice (w.type = \"precomputed\") indicate w.values argument. example, imagine want weight trajectory initial abundance sp2: comparison previous results, dDis increased decreased F, respectively, result greater abundance sp2 F . result interpreted lower isolation F relation trajectories initially dominated sp2. Weighting ecological trajectories equivalent modifying location trajectory taken reference. Therefore, recommend weight trajectories representative trajectory reference dDis make difficult interpretation results.","code":"# Change the trajectory identifier and the number of the state abundance_T2 <- RT_diversity$T2 abundance_T2$sampling_unit <- \"T2\" abundance_T2$time <- abundance_T2$RT_states  # Add representative trajectories' data to the abundance matrix abundance_T2 <- rbind(abundance, abundance_T2[, names(abundance)])  # Calculate state dissimilarities including the representative trajectory state_dissim_T2 <- vegan::vegdist(abundance_T2[, c(\"sp1\", \"sp2\")], method = \"bray\") # Compute dDis taking T2 as reference dDis_T2 <- dDis(d = state_dissim_T2, d.type = \"dStates\",           trajectories = abundance_T2$sampling_unit, states = abundance_T2$time,           reference = \"T2\") dDis_T2 #> dDis (ref. T2)  #>      0.1463935 # dDis: reference C dDis_I <- dDis(d = traj_dissim, d.type = \"dTraj\",           trajectories = ID_sampling,           reference = \"I\") # dDis: reference F dDis_F <- dDis(d = traj_dissim, d.type = \"dTraj\",           trajectories = ID_sampling,           reference = \"F\")  dDis_I #> dDis (ref. I)  #>     0.1847822 dDis_F #> dDis (ref. F)  #>     0.5809146 # Define w values initial_sp2 <- abundance[which(abundance$time == 1), ]$sp2  # Identify the index of the reference trajectories ind_I <- which(ID_sampling == \"I\") ind_F <- which(ID_sampling == \"F\")  # Compute dDis with weighted trajectories: # Considering I as reference dDis_I_w <- dDis(d = traj_dissim, d.type = \"dTraj\",           trajectories = ID_sampling, reference = \"I\",           w.type = \"precomputed\", w.values = initial_sp2[-ind_I]) # Considering F as reference dDis_F_w <- dDis(d = traj_dissim, d.type = \"dTraj\",           trajectories = ID_sampling, reference = \"F\",           w.type = \"precomputed\", w.values = initial_sp2[-ind_F]) dDis_I_w #> dDis (ref. I)  #>     0.2517555 dDis_F_w #> dDis (ref. F)  #>     0.4742493"},{"path":"https://mspinillos.github.io/ecoregime/articles/EDR_framework.html","id":"dynamic-beta-diversity-dbd","dir":"Articles","previous_headings":"5. Distribution and heterogeneity of ecological trajectories in EDRs","what":"5.2. Dynamic beta diversity (dBD)","title":"Ecological Dynamic Regime framework","text":"Dynamic beta diversity (dBD) proposed De Cáceres et al. (2019; Ecol. Monogr., https://doi.org/10.1002/ecm.1350) quantify overall variability group trajectories. Conceptually, measures average distance centroid trajectories. Therefore, quite similar dDis calculated taking representative trajectory reference. dBD implemented function dBD(). can imagine, dBD EDR small dynamical patterns trajectories similar.","code":"# Calculate dBD dBD(d = state_dissim, d.type = \"dStates\",      trajectories = rep(ID_sampling, each = 3), states = rep(ID_obs, 10)) #>        dBD  #> 0.06252172"},{"path":"https://mspinillos.github.io/ecoregime/articles/EDR_framework.html","id":"dynamic-evenness-deve","dir":"Articles","previous_headings":"5. Distribution and heterogeneity of ecological trajectories in EDRs","what":"5.3. Dynamic evenness (dEve)","title":"Ecological Dynamic Regime framework","text":"Dynamic evenness (dEve) quantifies regularity EDR filled ecological trajectories (Sánchez-Pinillos et al., 2023). metric informs existence groups trajectories within EDR. can compute dEve function dEve(): Like dDis, dEve can also calculated using different weights individual trajectories EDR. case, dEve equivalent functional evenness index proposed Villéger et al. (2003; Ecology, https://doi.org/10.1890/07-1206.1). example, weighting ecological trajectories initial abundance sp2 equivalent reducing dissimilarity trajectories dominated sp2 dEve increases.","code":"# Calculate dEve dEve(d = traj_dissim, d.type = \"dTraj\", trajectories = ID_sampling) #>      dEve  #> 0.5827095 # Calculate dEve weighting trajectories by the initial abundance of sp2 dEve(d = traj_dissim, d.type = \"dTraj\", trajectories = ID_sampling,          w.type = \"precomputed\", w.values = initial_sp2) #>      dEve  #> 0.6296034"},{"path":"https://mspinillos.github.io/ecoregime/articles/EDR_framework.html","id":"comparing-edrs","dir":"Articles","previous_headings":"","what":"6. Comparing EDRs","title":"Ecological Dynamic Regime framework","text":"Representative trajectories metrics dynamic dispersion, beta diversity, evenness allow characterize EDRs based dynamic patterns distribution ecological trajectories. Therefore, can compare two EDRs based features, saying “EDR dominated dynamics, whereas dynamics EDR different” “trajectories EDR diverse EDR”. want quantify different two EDRs ? common situation. Perhaps, want compare EDRs ecosystems different environmental conditions, example, forest communities dominated species grow different climatic conditions. Perhaps, want use simulated data assess effects introduction certain species EDRs. course, comparing EDR characteristics provide valuable information, want “number”, calculate dissimilarities EDRs. can using ecoregime. Let’s generate two EDRs compared previous one. use initial states first EDR define abundances sp1 sp2, introduce third species (sp3). third EDR composed trajectories dominated sp2 new species (sp4) able coexist equilibrium sp2: species abundances EDRs, need calculate trajectory dissimilarities: plot trajectories EDRs common state space, can see EDR2 closer EDR1 EDR3. surprising since species EDR1 present EDR2. contrast, EDR3 one species common EDRs.  Let’s see reflected dissimilarity matrix generated dist_edr(): expected, dissimilarity values EDR1 EDR2 smaller dissimilarities EDR3 , EDR1 EDR2.","code":"# ID of the sampling units for EDR2 ID_sampling2 <- paste0(\"inv_\", LETTERS[1:10])  # Define initial species abundances for sp3 set.seed(321) initial$sp3 <- round(runif(10, 0, 0.5), 2)  # Define the parameters for the Lotka-Volterra model parms2 <- c(r1 = 1, r2 = 0.1, a11 = 0.02, a21 = 0.03, a22 = 0.02, a12 = 0.01,            r3 = 1.5, a33 = 0.02, a31 = 0.01, a32 = 0.01, a13 = 0.1, a23 = 0.1)  # We can use primer to run the simulations simulated_abun2 <- lapply(1:nrow(initial), function(isampling){   # Initial abundance in the sampling unit i   initialN <- c(initial$sp1[isampling], initial$sp2[isampling], initial$sp3[isampling])   # Simulate community dynamics   simulated_abun <- data.frame(ode(y = initialN, times = ID_obs, func = lvcomp3, parms = parms2))   # Add the names of the sampling units   simulated_abun$sampling_unit <- ID_sampling2[isampling]   # Calculate relative abundances   simulated_abun$sp1 <- simulated_abun$X1/rowSums(simulated_abun[, c(\"X1\", \"X2\", \"X3\")])   simulated_abun$sp2 <- simulated_abun$X2/rowSums(simulated_abun[, c(\"X1\", \"X2\", \"X3\")])   simulated_abun$sp3 <- simulated_abun$X3/rowSums(simulated_abun[, c(\"X1\", \"X2\", \"X3\")])      return(simulated_abun[, c(\"sampling_unit\", \"time\", \"sp1\", \"sp2\", \"sp3\")]) })  # Compile species abundances of all sampling units in the same data frame abundance2 <- do.call(rbind, simulated_abun2) # ID of the sampling units for EDR3 ID_sampling3 <- LETTERS[11:20]  # Define initial species abundances set.seed(3) initial3 <- data.frame(sampling_units = ID_sampling3,                     sp4 = round(runif(10), 2))  # Define the parameters for the Lotka-Volterra model parms3 <- c(r1 = 1, r2 = 0.1, a11 = 0.2, a21 = 0.1, a22 = 0.02, a12 = 0.01)  # We can use primer to run the simulations simulated_abun3 <- lapply(1:nrow(initial), function(isampling){   # Initial abundance in the sampling unit i   initialN <- c(initial3$sp4[isampling], initial$sp2[isampling])   # Simulate community dynamics   simulated_abun <- data.frame(ode(y = initialN, times = ID_obs, func = lvcomp2, parms = parms3))   # Add the names of the sampling units   simulated_abun$sampling_unit <- ID_sampling3[isampling]   # Calculate relative abundances   simulated_abun$sp4 <- simulated_abun$X1/rowSums(simulated_abun[, c(\"X1\", \"X2\")])   simulated_abun$sp2 <- simulated_abun$X2/rowSums(simulated_abun[, c(\"X1\", \"X2\")])    return(simulated_abun[, c(\"sampling_unit\", \"time\", \"sp4\", \"sp2\")]) })  # Compile species abundances of all sampling units in the same data frame abundance3 <- do.call(rbind, simulated_abun3) # Bind all abundance matrices abundance_allEDR <- data.table::rbindlist(list(abundance, abundance2, abundance3), fill = T) abundance_allEDR[is.na(abundance_allEDR)] <- 0  # Calculate state dissimilarities including states in the three EDRs state_dissim_allEDR <- vegan::vegdist(abundance_allEDR[, paste0(\"sp\", 1:4)],                                        method = \"bray\")  # Calculate trajectory dissimilarities including trajectories in the three EDRs traj_dissim_allEDR <- ecotraj::trajectoryDistances(state_dissim_allEDR,                                                     sites = abundance_allEDR$sampling_unit,                                                    surveys = abundance_allEDR$time) # Multidimensional scaling st_mds_all <- smacof::smacofSym(state_dissim_allEDR,                                    ndim = nrow(as.matrix(state_dissim_allEDR))-1) st_mds_all <- data.frame(st_mds_all$conf)  # Plot ecological trajectories in the state space state.colorsEDRs <- rep(RColorBrewer::brewer.pal(3, \"Set1\"), each = 30) # Set an empty plot plot(st_mds_all$D1, st_mds_all$D2, type = \"n\",      xlab = \"Axis 1\", ylab = \"Axis 2\",      main = \"EDRs in the state space\") # Add arrows for (isampling in seq(1, 90, 3)) {   # From observation 1 to observation 2   shape::Arrows(st_mds_all[isampling, 1], st_mds_all[isampling, 2],          st_mds_all[isampling + 1, 1], st_mds_all[isampling + 1, 2],          col = state.colorsEDRs[isampling], arr.adj = 1)   # From observation 2 to observation 3   shape::Arrows(st_mds_all[isampling + 1, 1], st_mds_all[isampling + 1, 2],          st_mds_all[isampling + 2, 1], st_mds_all[isampling + 2, 2],          col = state.colorsEDRs[isampling], arr.adj = 1) }  # Add a legend legend(\"bottomleft\", paste0(\"EDR\", 1:3), col = unique(state.colorsEDRs), lty = 1) # Compute the dissimilarities between EDRs EDR_dissim <- dist_edr(d = traj_dissim_allEDR, d.type = \"dTraj\",                        edr = rep(c(\"EDR1\", \"EDR2\", \"EDR3\"), each = 10),                         metric = \"dDR\") round(EDR_dissim, 2) #>      EDR1 EDR2 EDR3 #> EDR1 0.00 0.25 0.73 #> EDR2 0.39 0.00 0.82 #> EDR3 0.67 0.71 0.00"},{"path":"https://mspinillos.github.io/ecoregime/articles/EDR_framework.html","id":"acknowledgements","dir":"Articles","previous_headings":"","what":"Acknowledgements","title":"Ecological Dynamic Regime framework","text":"project received funding European Union’s Horizon 2020 research innovation program Marie Sklodowska-Curie grant agreement 891477 (RESET project).","code":""},{"path":"https://mspinillos.github.io/ecoregime/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Martina Sánchez-Pinillos. Author, maintainer, copyright holder.","code":""},{"path":"https://mspinillos.github.io/ecoregime/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Sánchez-Pinillos M, Kéfi S, De Cáceres M, Dakos V (2023). “Ecological dynamic regimes: Identification, characterization, comparison.” Ecological Monographs. https://doi.org/10.1002/ecm.1589. Sánchez-Pinillos M (2023). ecoregime: Analysis Ecological Dynamic Regimes. https://doi.org/10.5281/zenodo.7584943.","code":"@Article{,   title = {Ecological dynamic regimes: Identification, characterization, and comparison},   author = {Martina Sánchez-Pinillos and Sonia Kéfi and Miquel {De Cáceres} and Vasilis Dakos},   year = {2023},   journal = {Ecological Monographs},   url = {https://doi.org/10.1002/ecm.1589}, } @Manual{,   title = {ecoregime: Analysis of Ecological Dynamic Regimes},   author = {Martina Sánchez-Pinillos},   year = {2023},   url = {https://doi.org/10.5281/zenodo.7584943}, }"},{"path":[]},{"path":"https://mspinillos.github.io/ecoregime/index.html","id":"analysis-of-ecological-dynamic-regimes","dir":"","previous_headings":"","what":"Analysis of Ecological Dynamic Regimes","title":"Analysis of Ecological Dynamic Regimes","text":"ecoregime implements EDR framework characterize compare groups ecological trajectories multidimensional spaces defined ecosystem state variables. EDR framework introduced : Sánchez-Pinillos, M., Kéfi, S., De Cáceres, M., Dakos, V. 2023. Ecological Dynamic Regimes: Identification, characterization, comparison. Ecological Monographs. doi:10.1002/ecm.1589","code":""},{"path":"https://mspinillos.github.io/ecoregime/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Analysis of Ecological Dynamic Regimes","text":"can install ecoregime via CRAN: can also install development version ecoregime : can get overview functionality workflow EDR framework package documentation vignette.","code":"install.packages(\"ecoregime\") # install.packages(\"devtools\") devtools::install_github(\"MSPinillos/ecoregime\") # Force the inclusion of the vignette in the installation devtools::install_github(\"MSPinillos/ecoregime\",                           build_opts = c(\"--no-resave-data\", \"--no-manual\"),                          build_vignettes = TRUE)  # Load the package after the installation library(ecoregime)  # Access the documentation and vignette ?ecoregime vignette(\"EDR_framework\", package = \"ecoregime\")"},{"path":"https://mspinillos.github.io/ecoregime/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Analysis of Ecological Dynamic Regimes","text":"Identify plot representative trajectories ecological dynamic regimes.  Characterize internal structure ecological dynamic regimes calculating dispersion (dDis), beta diversity (dBD), evenness (dEve) individual trajectories. Compare ecological dynamic regimes.","code":"library(ecoregime)  # Calculate state dissimilarities from a matrix of state variables (e.g., species abundances) variables <- data.frame(EDR_data$EDR1$abundance) d <- vegan::vegdist(variables[, -c(1:3)])  # Identify the trajectory (or site) and states in d trajectories <- variables$traj states <- as.integer(variables$state)  # Compute RETRA-EDR RT <- retra_edr(d = d, trajectories = trajectories, states = states,                  minSegs = 5)  # Plot representative trajectories of the EDR plot(x = RT, d = d, trajectories = trajectories, states = states, select_RT = \"T2\",      traj.colors = \"lightblue\", RT.colors = \"orange\", sel.color = \"darkgreen\",      link.lty = 1, asp = 1, main = \"Representative trajectories - EDR\") # Dynamic dispersion considering trajectory \"1\" as a reference dDis(d = d, d.type = \"dStates\", trajectories = trajectories, states = states, reference = \"1\") #> dDis (ref. 1)  #>      0.267622  # Dynamic beta diversity dBD(d = d, d.type = \"dStates\", trajectories = trajectories, states = states) #>        dBD  #> 0.03969095  # Dynamic evenness dEve(d = d, d.type = \"dStates\", trajectories = trajectories, states = states) #>      dEve  #> 0.7100773 # Load species abundances and compile in a data frame variables1 <- EDR_data$EDR1$abundance variables2 <- EDR_data$EDR2$abundance variables3 <- EDR_data$EDR3$abundance all_variables <- data.frame(rbind(variables1, variables2, variables3))  # Calculate dissimilarities between every pair of states d <- vegan::vegdist(all_variables[, -c(1:3)])  # Compute dissimilarities between EDRs: dist_edr(d = d, d.type = \"dStates\",          trajectories = all_variables$traj, states = all_variables$state,           edr = all_variables$EDR, metric = \"dDR\", symmetrize = NULL) #>           1         2         3 #> 1 0.0000000 0.5895458 0.3458250 #> 2 0.5700499 0.0000000 0.4907364 #> 3 0.4033212 0.6068221 0.0000000"},{"path":"https://mspinillos.github.io/ecoregime/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Analysis of Ecological Dynamic Regimes","text":"cite ecoregime publications use: Sánchez-Pinillos M, Kéfi S, De Cáceres M, Dakos V (2023). “Ecological dynamic regimes: Identification, characterization, comparison.” Ecological Monographs. https://doi.org/10.1002/ecm.1589. Sánchez-Pinillos M (2023). ecoregime: Analysis Ecological Dynamic Regimes. https://doi.org/10.5281/zenodo.7584943.","code":""},{"path":"https://mspinillos.github.io/ecoregime/index.html","id":"acknowledgements","dir":"","previous_headings":"","what":"Acknowledgements","title":"Analysis of Ecological Dynamic Regimes","text":"project received funding European Union’s Horizon 2020 research innovation program Marie Sklodowska-Curie grant agreement 891477 (RESET project).","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/EDR_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Ecological Dynamic Regime data — EDR_data","title":"Ecological Dynamic Regime data — EDR_data","text":"Example datasets characterize compare EDRs, including abundance data, state, segment, trajectory dissimilarity matrices 90 artificial communities belonging three different EDRs.","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/EDR_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ecological Dynamic Regime data — EDR_data","text":"","code":"EDR_data"},{"path":"https://mspinillos.github.io/ecoregime/reference/EDR_data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Ecological Dynamic Regime data — EDR_data","text":"List three nested sublists (\"EDR1\", \"EDR2\", \"EDR3\"), associated one EDR, including following elements: abundance: Data table 15 columns one row community state: EDR: Integer indicating identifier EDR. traj: Integer containing identifier trajectory artificial community corresponding EDR. trajectory represents different sampling unit. state: Integer indicating observations states community. sequence states given community forms trajectory. sp1, ..., sp12: Vectors containing species abundances community state. state_dissim: Object class dist containing Bray-Curtis dissimilarities every pair states abundance (see Details). segment_dissim: Object class dist containing dissimilarities every pair trajectory segments abundance (see Details). traj_dissim: Object class dist containing dissimilarities every pair community trajectories abundance (see Details).","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/EDR_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ecological Dynamic Regime data — EDR_data","text":"Artificial data generated following procedure explained Box 1 Sánchez-Pinillos et al. (2023) particular, initial state community defined using hypothetical environmental space optimal locations 12 species. Community dynamics simulated using general Lotka-Volterra model. State dissimilarities calculated using Bray-Curtis metric. Segment trajectory dissimilarities calculated using package 'ecotraj'.","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/EDR_data.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Ecological Dynamic Regime data — EDR_data","text":"Sánchez-Pinillos, M., Kéfi, S., De Cáceres, M., Dakos, V. 2023. Ecological Dynamic Regimes: Identification, characterization, comparison. Ecological Monographs. doi:10.1002/ecm.1589","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/EDR_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Metrics of Ecological Dynamic Regimes — EDR_metrics","title":"Metrics of Ecological Dynamic Regimes — EDR_metrics","text":"Set metrics analyze distribution variability trajectories Ecological Dynamic Regimes (EDR), including dynamic dispersion (dDis), dynamic beta diversity (dBD), dynamic evenness (dEve).","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/EDR_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Metrics of Ecological Dynamic Regimes — EDR_metrics","text":"","code":"dDis(   d,   d.type,   trajectories,   states = NULL,   reference,   w.type = \"none\",   w.values,   ... )  dBD(d, d.type, trajectories, states = NULL, ...)  dEve(d, d.type, trajectories, states = NULL, w.type = \"none\", w.values, ...)"},{"path":"https://mspinillos.github.io/ecoregime/reference/EDR_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metrics of Ecological Dynamic Regimes — EDR_metrics","text":"d Symmetric matrix object class dist containing dissimilarities pair states trajectories EDR dissimilarities pair trajectories. compute dDis, d needs include dissimilarities states/trajectories states/trajectory reference. d.type One \"dStates\" (d contains state dissimilarities) \"dTraj\" (d contains trajectory dissimilarities). trajectories Vector indicating trajectory site corresponding entry d. states d.type = \"dStates\". Vector integers indicating order states d trajectory. reference Vector class trajectories length equal one, indicating reference trajectory compute dDis. w.type Method used weight individual trajectories: \"none\": trajectories considered equally relevant (default). \"length\": Trajectories weighted length, calculated sum dissimilarities every pair consecutive states. d must contain dissimilarities trajectory states d.type = \"dStates\". \"size\": Trajectories weighted size, calculated number states forming trajectory. d must contain dissimilarities trajectory states d.type = \"dStates\". \"precomputed\": Trajectories weighted according different criteria. w.values w.type = \"precomputed\". Numeric vector length equal number trajectories containing weight trajectory. ... d.type = \"dStates\". arguments calculate trajectory dissimilarities. See ecotraj::trajectoryDistances().","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/EDR_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Metrics of Ecological Dynamic Regimes — EDR_metrics","text":"dDis() returns value dynamic dispersion given trajectory taken reference. dBD() returns value dynamic beta diversity. dEve() returns value dynamic evenness.","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/EDR_metrics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Metrics of Ecological Dynamic Regimes — EDR_metrics","text":"Dynamic dispersion (dDis()) dDis calculated average dissimilarity trajectory EDR target trajectory taken reference (Sánchez-Pinillos et al., 2023). \\( dDis = \\frac{\\sum_{=1}^{m}d_{\\alpha}}{m} \\) \\(d_{\\alpha}\\) dissimilarity trajectory \\(\\) trajectory reference \\(\\alpha\\), \\(m\\) number trajectories. Alternatively, possible calculate weighted mean dissimilarities assigning weight trajectory. \\( dDis = \\frac{\\sum_{=1}^{m}w_{}d_{\\alpha}}{\\sum_{=1}^{m}w_{}} \\) \\(w_{}\\) weight assigned trajectory \\(\\). Dynamic beta diversity (dBD()) dBD quantifies overall variation trajectories EDR equivalent average distance centroid EDR (De Cáceres et al., 2019). \\( dBD = \\frac{\\sum_{=1}^{m-1}\\sum_{j=+1}^{m}d_{ij}^{2}}{m(m-1)} \\) Dynamic evenness (dEve()) dEve quantifies regularity EDR filled individual trajectories (Sánchez-Pinillos et al., 2023). \\( dEve = \\frac{\\sum_{l=1}^{m-1}\\min(\\frac{d_{ij}}{\\sum_{l=1}^{m-1}d_{ij}}, \\frac{1}{m-1}) - \\frac{1}{m-1}}{1-\\frac{1}{1-1}} \\) \\(d_{ij}\\) dissimilarity trajectories \\(\\) \\(j\\) linked minimum spanning tree link \\(l\\). Optionally, possible weight trajectories EDR. case, dEve becomes analogous functional evenness index proposed Villéger et al. (2008). \\( dEve_{w} = \\frac{\\sum_{l=1}^{m-1}\\min(\\frac{EW_{ij}}{\\sum_{l=1}^{m-1}EW_{ij}}, \\frac{1}{m-1}) - \\frac{1}{m-1}}{1-\\frac{1}{1-1}} \\) \\(EW_{ij}\\) weighted evenness: \\( EW_{ij} = \\frac{d_{ij}}{w_i + w_j} \\)","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/EDR_metrics.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Metrics of Ecological Dynamic Regimes — EDR_metrics","text":"De Cáceres, M, Coll L, Legendre P, Allen RB, Wiser SK, Fortin MJ, Condit R & Hubbell S. (2019). Trajectory analysis community ecology. Ecological Monographs. Sánchez-Pinillos, M., Kéfi, S., De Cáceres, M., Dakos, V. 2023. Ecological Dynamic Regimes: Identification, characterization, comparison. Ecological Monographs. doi:10.1002/ecm.1589 Villéger, S., Mason, N.W.H., Mouillot, D. (2008) New multidimensional functional diversity indices multifaced framework functional ecology. Ecology.","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/EDR_metrics.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Metrics of Ecological Dynamic Regimes — EDR_metrics","text":"Martina Sánchez-Pinillos","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/EDR_metrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Metrics of Ecological Dynamic Regimes — EDR_metrics","text":"","code":"# Data to compute dDis, dBD, and dEve dStates <- EDR_data$EDR1$state_dissim dTraj <- EDR_data$EDR1$traj_dissim trajectories <- paste0(\"T\", EDR_data$EDR1$abundance$traj) states <- EDR_data$EDR1$abundance$state  # Dynamic dispersion taking the first trajectory as reference dDis(d = dTraj, d.type = \"dTraj\", trajectories = unique(trajectories),          reference = \"T1\") #> dDis (ref. T1)  #>       0.267622   # Dynamic dispersion weighting trajectories by their length dDis(d = dStates, d.type = \"dStates\", trajectories = trajectories, states = states,          reference = \"T1\", w.type = \"length\") #> dDis (ref. T1)  #>      0.3548963   # Dynamic beta diversity using trajectory dissimilarities dBD(d = dTraj, d.type = \"dTraj\", trajectories = unique(trajectories)) #>        dBD  #> 0.03969095   # Dynamic evenness dEve(d = dStates, d.type = \"dStates\", trajectories = trajectories, states = states) #>      dEve  #> 0.7100773   # Dynamic evenness considering that the 10 first trajectories are three times # more relevant than the rest w.values <- c(rep(3, 10), rep(1, length(unique(trajectories))-10)) dEve(d = dTraj, d.type = \"dTraj\", trajectories = unique(trajectories),          w.type = \"precomputed\", w.values = w.values) #>      dEve  #> 0.7392367"},{"path":"https://mspinillos.github.io/ecoregime/reference/define_retra.html","id":null,"dir":"Reference","previous_headings":"","what":"Define representative trajectories from trajectory features — define_retra","title":"Define representative trajectories from trajectory features — define_retra","text":"Generate object class RETRA data frame containing trajectory states define representative trajectories Ecological Dynamic Regimes (EDR).","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/define_retra.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define representative trajectories from trajectory features — define_retra","text":"","code":"define_retra(data, d = NULL, trajectories = NULL, states = NULL, retra = NULL)"},{"path":"https://mspinillos.github.io/ecoregime/reference/define_retra.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define representative trajectories from trajectory features — define_retra","text":"data data frame four columns indicating identifiers new representative trajectories, individual trajectories sites states belong, order states individual trajectories, identifier representative trajectory states belong (!.null(retra)). Alternatively, 'data' can vector list character vectors including sequence segments forming new representative trajectory. See Details clarifications define data. d Either symmetric matrix object class dist containing dissimilarities pair states trajectories EDR. NULL (default), length (Length) new representative trajectories distances states different trajectories sites (Link_distance) calculated. trajectories needed !.null(d). Vector indicating trajectory site state d belongs. states needed !.null(d). Vector integers indicating order states d trajectory. retra Object class RETRA returned retra_edr(). NULL (default), minSegs Seg_density provided new representative trajectories.","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/define_retra.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define representative trajectories from trajectory features — define_retra","text":"object class RETRA, list length equal number representative trajectories defined. trajectory, following information returned: minSegs Value minSegs parameter used retra_edr(). retra NULL, minSegs = NA. Segments Vector strings including sequence segments forming representative trajectory. segment identified string form traj[st1-st2], traj identifier original trajectory segment belongs st1 st2 identifiers initial final states defining segment. format traj[st1-st2] maintained one state individual trajectory considered (st1 = st2). traj, st1, st2 recycled data. Size Integer indicating number states forming representative trajectory. Length Numeric value indicating length representative trajectory, calculated sum dissimilarities d every pair consecutive states. d NULL, Length = NA. Link_distance Data frame two columns indicating artificial links two segments (Link) dissimilarity connected states (Distance). two representative segments linked common state two consecutive states trajectory, link distance zero equal length real segment, respectively. cases, link considered returned data frame. d NULL, Link_distance = NA. Seg_density Data frame two columns one row representative segment. Density contains number segments EDR represented segment representative trajectory. kdTree_depth contains depth k-d tree leaf represented corresponding segment. , number partitions ordination space finding region minSegs segments less. retra NULL, Seg_density = NA.","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/define_retra.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Define representative trajectories from trajectory features — define_retra","text":"representative trajectory returned function retra_edr() corresponds longest sequence representative segments can linked according criteria defined RETRA-EDR algorithm (Sánchez-Pinillos et al., 2023). One interested splitting obtained trajectories, considering fraction returned trajectories, defining representative trajectories following different criteria RETRA-EDR. function define_retra() allows generating object class RETRA can used functions ecoregime (e.g., plot()). , necessary provide information set segments trajectory states form new representative trajectory argument data: data can defined data frame many rows number states representative trajectories following columns: RT string indicating identifier new representative trajectories. identifier needs appear many times number states forming representative trajectory. RT_traj vector indicating individual trajectories EDR state new representative trajectory belongs. RT_states vector integers indicating identifier states forming new representative trajectories. integer must refer order states individual trajectories EDR belong. RT_retra new trajectories defined representative trajectories returned retra_edr() (!.null(retra)). vector strings indicating representative trajectory retra state belongs. Alternatively, data can defined either vector (one representative trajectory) list character vectors (many elements number representative trajectories desired) containing sequence segments representative trajectories. case, segment needs specified form traj[st1-st2], traj identifier original trajectory segment belongs st1 st2 identifiers initial final states defining segment. one state individual trajectory considered form representative trajectory, corresponding segment needs defined traj[st-st].","code":""},{"path":[]},{"path":"https://mspinillos.github.io/ecoregime/reference/define_retra.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Define representative trajectories from trajectory features — define_retra","text":"Martina Sánchez-Pinillos","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/define_retra.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define representative trajectories from trajectory features — define_retra","text":"","code":"# Example 1 ----------------------------------------------------------------- # Define representative trajectories from the outputs of retra_edr().  # Identify representative trajectories using retra_edr() d <- EDR_data$EDR1$state_dissim trajectories <- EDR_data$EDR1$abundance$traj states <- EDR_data$EDR1$abundance$state old_retra <- retra_edr(d = d, trajectories = trajectories, states = states,                        minSegs = 5)  # retra_edr() returns three representative trajectories old_retra #> $T1 #> $T1$minSegs #> [1] 5 #>  #> $T1$Segments #> [1] \"28[1-2]\" \"28[2-3]\" #>  #> $T1$Size #> [1] 3 #>  #> $T1$Length #> [1] 0.2669408 #>  #> $T1$Link_distance #> [1] NA #>  #> $T1$Seg_density #>         Density kdTree_depth #> 28[1-2]       7            4 #> 28[2-3]       6            5 #>  #>  #> $T2 #> $T2$minSegs #> [1] 5 #>  #> $T2$Segments #> [1] \"28[1-2]\" \"30[2-3]\" \"5[3-4]\"  \"15[1-2]\" \"4[2-3]\"  \"4[3-4]\"  \"1[1-2]\"  #> [8] \"14[2-3]\" #>  #> $T2$Size #> [1] 15 #>  #> $T2$Length #> [1] 0.9270207 #>  #> $T2$Link_distance #>                Link    Distance #> 1 28[1-2] - 30[2-3] 0.074626866 #> 2  30[2-3] - 5[3-4] 0.045685279 #> 3  5[3-4] - 15[1-2] 0.144278607 #> 4  15[1-2] - 4[2-3] 0.035175879 #> 5   4[3-4] - 1[1-2] 0.010000000 #> 6  1[1-2] - 14[2-3] 0.004926108 #>  #> $T2$Seg_density #>         Density kdTree_depth #> 28[1-2]       7            4 #> 30[2-3]       6            5 #> 5[3-4]        6            5 #> 15[1-2]       6            6 #> 4[2-3]        7            7 #> 4[3-4]        9            5 #> 1[1-2]        9            3 #> 14[2-3]       7            6 #>  #>  #> $T3 #> $T3$minSegs #> [1] 5 #>  #> $T3$Segments #> [1] \"6[1-2]\"  \"5[3-4]\"  \"15[1-2]\" \"4[2-3]\"  \"4[3-4]\"  \"1[1-2]\"  \"14[2-3]\" #>  #> $T3$Size #> [1] 13 #>  #> $T3$Length #> [1] 0.6756596 #>  #> $T3$Link_distance #>               Link    Distance #> 1  6[1-2] - 5[3-4] 0.020202020 #> 2 5[3-4] - 15[1-2] 0.144278607 #> 3 15[1-2] - 4[2-3] 0.035175879 #> 4  4[3-4] - 1[1-2] 0.010000000 #> 5 1[1-2] - 14[2-3] 0.004926108 #>  #> $T3$Seg_density #>         Density kdTree_depth #> 6[1-2]        8            5 #> 5[3-4]        6            5 #> 15[1-2]       6            6 #> 4[2-3]        7            7 #> 4[3-4]        9            5 #> 1[1-2]        9            3 #> 14[2-3]       7            6 #>  #>  #> attr(,\"class\") #> [1] \"RETRA\"  # Keep the last five segments of trajectories \"T2\" and \"T3\" selected_segs <- old_retra$T2$Segments[4:length(old_retra$T2$Segments)]  # Identify the individual trajectories for each state... selected_segs #> [1] \"15[1-2]\" \"4[2-3]\"  \"4[3-4]\"  \"1[1-2]\"  \"14[2-3]\" selected_traj <- rep(c(15, 4, 4, 1, 14), each = 2)  # ...and the states (in the same order as the representative trajectory). selected_states <- c(1, 2, 2, 3, 3, 4, 1, 2, 2, 3)  # Generate the data frame with the format indicated in the documentation df <- data.frame(RT = rep(\"A\", length(selected_states)),                  RT_traj = selected_traj,                  RT_states = as.integer(selected_states),                  RT_retra = rep(\"T2\", length(selected_states)))  # Remove duplicates (trajectory 4, state 3) df <- unique(df)  # Generate a RETRA object using define_retra() new_retra <- define_retra(data = df,                           d = d,                           trajectories = trajectories,                           states = states,                           retra = old_retra)  # Example 2 ----------------------------------------------------------------- # Define representative trajectories from sequences of segments  # Select all segments in T1, split T2 into two new trajectories, and include # a trajectory composed of states belonging to trajectories \"5\", \"6\", and \"7\" data <- list(old_retra$T1$Segments,              old_retra$T2$Segments[1:3],              old_retra$T2$Segments[4:8],              c(\"5[1-2]\", \"5[2-3]\", \"7[4-4]\", \"6[4-5]\"))  # Generate a RETRA object using define_retra() new_retra <- define_retra(data = data,                           d = d,                           trajectories = trajectories,                           states = states,                           retra = old_retra)  # Example 3 ----------------------------------------------------------------- # Define two representative trajectories from individual trajectories in EDR1.  # Define trajectory \"A\" from states in trajectories 3 and 4 data_A <- data.frame(RT = rep(\"A\", 4),                      RT_traj = c(3, 3, 4, 4),                      RT_states = c(1:2, 4:5))  # Define trajectory \"B\" from states in trajectories 5, 6, and 7 data_B <- data.frame(RT = rep(\"B\", 5),                      RT_traj = c(5, 5, 7, 6, 6),                      RT_states = c(1, 2, 4, 4, 5))  # Compile data for both trajectories in a data frame df <- rbind(data_A, data_B) df$RT_states <- as.integer(df$RT_states)  # Generate a RETRA object using define_retra() new_retra <- define_retra(data = df, d = EDR_data$EDR1$state_dissim,                           trajectories = EDR_data$EDR1$abundance$traj,                           states = EDR_data$EDR1$abundance$state)"},{"path":"https://mspinillos.github.io/ecoregime/reference/dist_edr.html","id":null,"dir":"Reference","previous_headings":"","what":"Dissimilarities between Ecological Dynamic Regimes — dist_edr","title":"Dissimilarities between Ecological Dynamic Regimes — dist_edr","text":"Generate matrix containing dissimilarities one pairs Ecological Dynamic Regimes (EDR). dist_edr() computes different dissimilarity indices, based dissimilarities trajectories two EDRs.","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/dist_edr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dissimilarities between Ecological Dynamic Regimes — dist_edr","text":"","code":"dist_edr(   d,   d.type,   trajectories = NULL,   states = NULL,   edr,   metric = \"dDR\",   symmetrize = NULL,   ... )"},{"path":"https://mspinillos.github.io/ecoregime/reference/dist_edr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dissimilarities between Ecological Dynamic Regimes — dist_edr","text":"d Symmetric matrix object class dist containing dissimilarities pair states trajectories EDR dissimilarities pair trajectories. d.type One \"dStates\" (d contains state dissimilarities) \"dTraj\" (d contains trajectory dissimilarities). trajectories d.type = \"dStates\". Vector indicating trajectory site corresponding entry d. states d.type = \"dStates\". Vector integers indicating order states d trajectory. edr Vector indicating EDR trajectory/state d belongs. metric string indicating dissimilarity index used: \"dDR\" (default), \"minDist\", \"maxDist\". symmetrize String naming function called symmetrize resulting dissimilarity matrix (\"mean\", \"min\", \"max, \"lower\", \"upper\"). NULL (default), matrix symmetrized. ... d.type = \"dStates\". arguments calculate trajectory dissimilarities. See ecotraj::trajectoryDistances().","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/dist_edr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dissimilarities between Ecological Dynamic Regimes — dist_edr","text":"Matrix including dissimilarities every pair EDRs.","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/dist_edr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dissimilarities between Ecological Dynamic Regimes — dist_edr","text":"implemented metrics : \"dDR\" \\( d_{DR}(R_1, R_2) = \\frac{1}{n} \\sum_{=1}^{n} d_{TR}(T_{1i}, R_2) \\) \"minDist\" \\( d_{DRmin}(R_1, R_2) = \\min_{=1}^{n} \\{ d_{TR}(T_{1i}, R_2) \\} \\) \"maxDist\" \\( d_{DRmax}(R_1, R_2) = \\max_{=1}^{n} \\{ d_{TR}(T_{1i}, R_2) \\} \\) \\(R_1\\) \\(R_2\\) two EDRs composed \\(n\\) \\(m\\) ecological trajectories, respectively, \\(d_{TR}(T_{1i}, R_2)\\) dissimilarity trajectory \\(T_{1i}\\) \\(R_1\\) closest trajectory \\(R_2\\): \\( d_{TR}(T_{1i}, R_2) = \\min\\{d_T(T_{1i}, T_{21}), ... , d_T(T_{1i}, T_{2m})\\} \\) metrics calculated necessarily symmetric. , \\(d_{DR}(R_1, R_2)\\) necessarily equal \\(d_{DR}(R_2, R_1)\\). possible symmetrize returned matrix indicating name function used symmetrize: \"mean\" \\( d_{DRsym} = \\frac{d_{DR}(R_1, R_2) + d_{DR}(R_2, R_1)}{2} \\) \"min\" \\( d_{DRsym} = \\min\\{d_{DR}(R_1, R_2), d_{DR}(R_2, R_1)\\} \\) \"max\" \\( d_{DRsym} = \\max\\{d_{DR}(R_1, R_2), d_{DR}(R_2, R_1)\\} \\) \"lower\" lower triangular part dissimilarity matrix used. \"upper\" upper triangular part dissimilarity matrix used.","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/dist_edr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Dissimilarities between Ecological Dynamic Regimes — dist_edr","text":"Sánchez-Pinillos, M., Kéfi, S., De Cáceres, M., Dakos, V. 2023. Ecological Dynamic Regimes: Identification, characterization, comparison. Ecological Monographs. doi:10.1002/ecm.1589","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/dist_edr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Dissimilarities between Ecological Dynamic Regimes — dist_edr","text":"Martina Sánchez-Pinillos","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/dist_edr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dissimilarities between Ecological Dynamic Regimes — dist_edr","text":"","code":"# Load species abundances and compile in a data frame abun1 <- EDR_data$EDR1$abundance abun2 <- EDR_data$EDR2$abundance abun3 <- EDR_data$EDR3$abundance abun <- data.frame(rbind(abun1, abun2, abun3))  # Define row names in abun to keep the reference of the EDR, trajectory, and # state row.names(abun) <- paste0(abun$EDR, \"_\", abun$traj, \"_\", abun$state)  # Calculate dissimilarities between every pair of states # For example, Bray-Curtis index dStates <- vegan::vegdist(abun[, -c(1, 2, 3)], method = \"bray\")  # Use the labels in dStates to define the trajectories to which each state # belongs id_traj <- vapply(strsplit(labels(dStates), \"_\"), function(x){                     paste0(x[1], \"_\", x[2])                 }, character(1)) id_state <- vapply(strsplit(labels(dStates), \"_\"), function(x){                     as.integer(x[3])                 }, integer(1)) id_edr <- vapply(strsplit(labels(dStates), \"_\"), function(x){                     paste0(\"EDR\", x[1])                 }, character(1))  # Calculate dissimilarities between every pair of trajectories dTraj <- ecotraj::trajectoryDistances(d = dStates, sites = id_traj,                                       surveys = id_state,                                       distance.type = \"DSPD\")  # Use labels in dTraj to identify EDRs id_edr_traj <- vapply(strsplit(labels(dTraj), \"_\"), function(x){                     paste0(\"EDR\", x[1])                 }, character(1))  # Compute dissimilarities between EDRs: # 1.1) without symmetrizing the matrix and using state dissimilarities dEDR <- dist_edr(d = dStates, d.type = \"dStates\",                  trajectories = id_traj, states = id_state, edr = id_edr,                  metric = \"dDR\", symmetrize = NULL)  # 1.2) without symmetrizing the matrix and using trajectory dissimilarities dEDR <- dist_edr(d = dTraj, d.type = \"dTraj\", edr = id_edr_traj,                  metric = \"dDR\", symmetrize = NULL)  # 2) symmetrizing by averaging elements on and below the diagonal dEDR <- dist_edr(d = dTraj, d.type = \"dTraj\", edr = id_edr_traj,                  metric = \"dDR\", symmetrize = \"mean\")"},{"path":"https://mspinillos.github.io/ecoregime/reference/ecoregime-package.html","id":null,"dir":"Reference","previous_headings":"","what":"ecoregime: Analysis of Ecological Dynamic Regimes — ecoregime-package","title":"ecoregime: Analysis of Ecological Dynamic Regimes — ecoregime-package","text":"toolbox implementing Ecological Dynamic Regime framework (Sánchez-Pinillos et al., 2023 doi:10.1002/ecm.1589 ) characterize compare groups ecological trajectories multidimensional spaces defined state variables. package includes RETRA-EDR algorithm identify representative trajectories, functions generate, summarize, visualize representative trajectories, several metrics quantify distribution heterogeneity trajectories ecological dynamic regime quantify dissimilarity two ecological dynamic regimes.","code":""},{"path":[]},{"path":"https://mspinillos.github.io/ecoregime/reference/ecoregime-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"ecoregime: Analysis of Ecological Dynamic Regimes — ecoregime-package","text":"Maintainer: Martina Sánchez-Pinillos martina.sanchez.pinillos@gmail.com (ORCID) [copyright holder]","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/plot.RETRA.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot representative trajectories of Ecological Dynamic Regimes — plot.RETRA","title":"Plot representative trajectories of Ecological Dynamic Regimes — plot.RETRA","text":"Plot representative trajectories Ecological Dynamic Regime (EDR) state space distinguishing segments belonging real trajectories EDR artificial links segments.","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/plot.RETRA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot representative trajectories of Ecological Dynamic Regimes — plot.RETRA","text":"","code":"# S3 method for RETRA plot(   x,   d,   trajectories,   states,   select_RT = NULL,   traj.colors = NULL,   RT.colors = NULL,   sel.color = NULL,   link.color = NULL,   link.lty = 2,   axes = c(1, 2),   ... )"},{"path":"https://mspinillos.github.io/ecoregime/reference/plot.RETRA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot representative trajectories of Ecological Dynamic Regimes — plot.RETRA","text":"x Object class RETRA. d Symmetric matrix dist object containing dissimilarities pair states trajectories EDR data frame containing coordinates trajectory states ordination space. trajectories Vector indicating trajectory site state d belongs. states Vector integers indicating order states d trajectory. select_RT Optional string indicating name representative trajectory must highlighted plot. default (select_RT = NULL), representative trajectories represented color. traj.colors Specification color individual trajectories (defaults \"grey\") vector length equal number trajectories indicating color individual trajectory. RT.colors Specification color representative trajectories (defaults \"black\"). sel.color Specification color selected representative trajectory (defaults \"red\"). !.null(select_RT). link.color Specification color links trajectory segments forming representative trajectories. default, color RT.colors used. link.lty line type links trajectory segments forming representative trajectories. Defaults 2 = \"dashed\" (See graphics::par). axes integer vector indicating pair axes ordination space plotted. ... Arguments generic plot().","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/plot.RETRA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot representative trajectories of Ecological Dynamic Regimes — plot.RETRA","text":"function plot() plots set individual trajectories representative trajectories ordination space defined d calculated applying metric multidimensional scaling (mMDS; Borg Groenen, 2005) d.","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/plot.RETRA.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Plot representative trajectories of Ecological Dynamic Regimes — plot.RETRA","text":"Borg, ., & Groenen, P. J. F. (2005). Modern Multidimensional Scaling (2nd ed.). Springer. Sánchez-Pinillos, M., Kéfi, S., De Cáceres, M., Dakos, V. 2023. Ecological Dynamic Regimes: Identification, characterization, comparison. Ecological Monographs. doi:10.1002/ecm.1589","code":""},{"path":[]},{"path":"https://mspinillos.github.io/ecoregime/reference/plot.RETRA.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot representative trajectories of Ecological Dynamic Regimes — plot.RETRA","text":"Martina Sánchez-Pinillos","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/plot.RETRA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot representative trajectories of Ecological Dynamic Regimes — plot.RETRA","text":"","code":"# Example 1 -----------------------------------------------------------------  # d contains the dissimilarities between trajectory states d <- EDR_data$EDR1$state_dissim  # trajectories and states are defined according to `d` entries. trajectories <- EDR_data$EDR1$abundance$traj states <- EDR_data$EDR1$abundance$state  # x defined from retra_edr(). We obtain three representative trajectories. RT <- retra_edr(d = d, trajectories = trajectories, states = states, minSegs = 5) summary(RT) #>    ID Size    Length   Avg_link  Sum_link Avg_density Max_density Avg_depth #> T1 T1    3 0.2669408         NA        NA    6.500000           7  4.500000 #> T2 T2   15 0.9270207 0.05244879 0.3146927    7.125000           9  5.125000 #> T3 T3   13 0.6756596 0.04291652 0.2145826    7.428571           9  5.285714 #>    Max_depth #> T1         5 #> T2         7 #> T3         7  # Plot individual trajectories in blue and representative trajectories in orange, # \"T2\" will be displayed in green. Artificial links will be displayed with a # dotted line. plot(x = RT, d = d, trajectories = trajectories, states = states, select_RT = \"T2\",      traj.colors = \"lightblue\", RT.colors = \"orange\", sel.color = \"darkgreen\",      link.lty = 3, main = \"Representative trajectories in EDR1\")   # Example 2 -----------------------------------------------------------------  # d contains the coordinates in an ordination space. For example, we use # the coordinates of the trajectory states after applying a principal component # analysis (PCA) to an abundance matrix. abun <- EDR_data$EDR1$abundance pca <- prcomp(abun[, -c(1:3)]) coord <- data.frame(pca$x)  # trajectories and states are defined according to the abundance matrix # used in the PCA trajectories <- EDR_data$EDR1$abundance$traj states <- EDR_data$EDR1$abundance$state  # Instead of using the representative trajectories obtained from `retra_edr()`, # we will define the set of trajectories that we want to highlight. For example, # we can select the trajectories whose initial and final states are in the # extremes of the first axis. T1 <- trajectories[which.max(coord[, 1])] T2 <- trajectories[which.min(coord[, 1])] RT_traj <- c(trajectories[trajectories %in% T1],              trajectories[trajectories %in% T2]) RT_states <- c(states[which(trajectories %in% T1)],                states[which(trajectories %in% T2)])  # Create a data frame to generate a RETRA object using define_retra RT_df <- data.frame(RT = c(rep(\"T1\", sum(trajectories %in% T1)),                            rep(\"T2\", sum(trajectories %in% T2))),                  RT_traj = RT_traj,                  RT_states = as.integer(RT_states)) RT_retra <- define_retra(data = RT_df)  # Plot the defined trajectories with the default graphic values plot(x = RT_retra, d = coord, trajectories = trajectories, states = states,      main = \"Extreme trajectories in EDR1\")"},{"path":"https://mspinillos.github.io/ecoregime/reference/retra_edr.html","id":null,"dir":"Reference","previous_headings":"","what":"Representative trajectories in Ecological Dynamic Regimes (RETRA-EDR) — retra_edr","title":"Representative trajectories in Ecological Dynamic Regimes (RETRA-EDR) — retra_edr","text":"retra_edr() applies algorithm RETRA-EDR (Sánchez-Pinillos et al., 2023) identify representative trajectories summarizing main dynamical patterns Ecological Dynamic Regime (EDR).","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/retra_edr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Representative trajectories in Ecological Dynamic Regimes (RETRA-EDR) — retra_edr","text":"","code":"retra_edr(   d,   trajectories,   states,   minSegs,   dSegs = NULL,   coordSegs = NULL,   traj_Segs = NULL,   state1_Segs = NULL,   state2_Segs = NULL,   Dim = NULL,   eps = 0 )"},{"path":"https://mspinillos.github.io/ecoregime/reference/retra_edr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Representative trajectories in Ecological Dynamic Regimes (RETRA-EDR) — retra_edr","text":"d Either symmetric matrix object class dist containing dissimilarities pair states trajectories EDR. trajectories Vector indicating trajectory site state d belongs. states Vector integers indicating order states d trajectory. minSegs Integer indicating minimum number segments region EDR represented segment representative trajectory. dSegs Either symmetric matrix object class dist containing dissimilarities every pair trajectory segments (see Details). coordSegs Matrix containing coordinates trajectory segments (rows) axis (columns) ordination space (see Details). traj_Segs Vector indicating trajectory segment dSeg /coordSegs belongs. required dSegs coordSegs NULL. state1_Segs Vector indicating initial state segment dSegs /coordSegs according values given states. required dSegs coordSegs NULL. state2_Segs Vector indicating final state segment dSegs /coordSegs according values given states. required dSegs coordSegs NULL. Dim Optional integer indicating number axes considered partition segment space generate k-d tree. default (Dim = NULL), axes considered. eps Numeric value indicating minimum length axes segment space partitioned k-d tree generated. eps = 0 (default), partitions made regardless size.","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/retra_edr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Representative trajectories in Ecological Dynamic Regimes (RETRA-EDR) — retra_edr","text":"function retra_edr() returns object class RETRA, list length equal number representative trajectories identified. trajectory, following information returned: minSegs Value minSegs parameter. Segments Vector strings including sequence segments forming representative trajectory. segment identified string form traj[st1-st2], traj identifier original trajectory segment belongs st1 st2 identifiers initial final states defining segment. Size Numeric value indicating number states forming representative trajectory. Length Numeric value indicating length representative trajectory, calculated sum dissimilarities d every pair consecutive states. Link_distance Data frame two columns indicating artificial links representative segments (Link) dissimilarity connected states (Distance). two representative segments linked common state two consecutive states trajectory, link distance zero equal length real segment, respectively. cases, link considered returned data frame. Seg_density Data frame two columns one row representative segment. Density contains number segments EDR represented segment representative trajectory. kdTree_depth contains depth k-d tree leaf represented corresponding segment. , number partitions ordination space finding region minSegs segments less.","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/retra_edr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Representative trajectories in Ecological Dynamic Regimes (RETRA-EDR) — retra_edr","text":"algorithm RETRA-EDR based partition--group approach identifies regions densely crossed ecological trajectories EDR, selects representative segment dense region, joins representative segments set artificial Links generate network representative trajectories. , RETRA-EDR splits trajectories EDR segments uses ordination space generated matrix containing dissimilarities trajectory segments. Dense regions identified applying k-d tree ordination space. default, RETRA-EDR calculates segment dissimilarities following approach De Cáceres et al. (2019) applies metric multidimensional scaling (mMDS, Borg Groenen, 2005) generate ordination space. possible use dissimilarity metrics /ordination methods reduce computational time indicating dissimilarity matrix coordinates segments ordination space arguments dSegs coordSegs, respectively. !.null(dSegs) .null(coordSegs), RETRA-EDR computed applying mMDS dSegs. !.null(dSegs) !.null(coordSegs), RETRA-EDR directly computed coordinates provided coordSegs representative segments identified using dSegs. coordSegs calculated user dSegs. .null(dSegs) !.null(coordSegs) (recommended), RETRA-EDR directly computed coordinates provided coordSegs. dSegs provided, retra_edr() assumes ordination space metric identifies representative segments using Euclidean distance.","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/retra_edr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Representative trajectories in Ecological Dynamic Regimes (RETRA-EDR) — retra_edr","text":"Borg, ., & Groenen, P. J. F. (2005). Modern Multidimensional Scaling (2nd ed.). Springer. De Cáceres, M, Coll L, Legendre P, Allen RB, Wiser SK, Fortin MJ, Condit R & Hubbell S. (2019). Trajectory analysis community ecology. Ecological Monographs. Sánchez-Pinillos, M., Kéfi, S., De Cáceres, M., Dakos, V. 2023. Ecological Dynamic Regimes: Identification, characterization, comparison. Ecological Monographs. doi:10.1002/ecm.1589","code":""},{"path":[]},{"path":"https://mspinillos.github.io/ecoregime/reference/retra_edr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Representative trajectories in Ecological Dynamic Regimes (RETRA-EDR) — retra_edr","text":"Martina Sánchez-Pinillos","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/retra_edr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Representative trajectories in Ecological Dynamic Regimes (RETRA-EDR) — retra_edr","text":"","code":"# Example 1 ----------------------------------------------------------------- # Identify representative trajectories from state dissimilarities  # Calculate state dissimilarities (Bray-Curtis) from species abundances abundance <- data.frame(EDR_data$EDR1$abundance) d <- vegan::vegdist(abundance[, -c(1:3)], method = \"bray\")  # Identify the trajectory (or site) and states in d trajectories <- abundance$traj states <- as.integer(abundance$state)  # Compute RETRA-EDR RT1 <- retra_edr(d = d, trajectories = trajectories, states = states,                  minSegs = 5)  # Example 2 ----------------------------------------------------------------- # Identify representative trajectories from segment dissimilarities  # Calculate segment dissimilarities using the Hausdorff distance dSegs <- ecotraj::segmentDistances(d = d, sites = trajectories,                                     surveys = states,                                     distance.type = \"Hausdorff\") dSegs <- dSegs$Dseg  # Identify the trajectory (or site) and states in dSegs: # Split the labels of dSegs (traj[st1-st2]) into traj, st1, and st2 seg_components <- strsplit(gsub(\"\\\\]\", \"\", gsub(\"\\\\[\", \"-\", labels(dSegs))), \"-\") traj_Segs <- sapply(seg_components, \"[\", 1) state1_Segs <- as.integer(sapply(seg_components, \"[\", 2)) state2_Segs <- as.integer(sapply(seg_components, \"[\", 3))  # Compute RETRA-EDR RT2 <- retra_edr(d = d, trajectories = trajectories, states = states, minSegs = 5,                 dSegs = dSegs, traj_Segs = traj_Segs,                 state1_Segs = state1_Segs, state2_Segs = state2_Segs)"},{"path":"https://mspinillos.github.io/ecoregime/reference/summary.RETRA.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize representative trajectories — summary.RETRA","title":"Summarize representative trajectories — summary.RETRA","text":"Summarize properties representative trajectories returned retra_edr() define_retra()","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/summary.RETRA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize representative trajectories — summary.RETRA","text":"","code":"# S3 method for RETRA summary(object, ...)"},{"path":"https://mspinillos.github.io/ecoregime/reference/summary.RETRA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize representative trajectories — summary.RETRA","text":"object object class RETRA. ... (used)","code":""},{"path":"https://mspinillos.github.io/ecoregime/reference/summary.RETRA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize representative trajectories — summary.RETRA","text":"Data frame nine columns one row representative trajectory object. columns returned data frame contain following information: ID Identifier representative trajectories. Size Number states forming representative trajectory. Length Sum dissimilarities d every pair consecutive states forming representative trajectories. Avg_link Mean value dissimilarities consecutive states representative trajectories belong ecological trajectory site (.e., artificial links). Sum_link Sum dissimilarities consecutive states representative trajectories belong ecological trajectory site (.e., artificial links). Avg_density Mean value number segments represented segment representative trajectory (excluding artificial links). Max_density Maximum number segments represented least one segments representative trajectory (excluding artificial links). Avg_depth Mean value k-d tree depths, , number partitions ordination space finding region minSegs segments less. Max_depth Maximum depth k-d tree, , number partitions ordination space finding region minSegs segments less.","code":""},{"path":[]},{"path":"https://mspinillos.github.io/ecoregime/reference/summary.RETRA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize representative trajectories — summary.RETRA","text":"","code":"# Apply RETRA-EDR to identify representative trajectories d = EDR_data$EDR1$state_dissim trajectories = EDR_data$EDR1$abundance$traj states = EDR_data$EDR1$abundance$state RT <- retra_edr(d = d, trajectories = trajectories, states = states, minSegs = 5)  # Summarize the properties of the representative trajectories in a data frame summary(RT) #>    ID Size    Length   Avg_link  Sum_link Avg_density Max_density Avg_depth #> T1 T1    3 0.2669408         NA        NA    6.500000           7  4.500000 #> T2 T2   15 0.9270207 0.05244879 0.3146927    7.125000           9  5.125000 #> T3 T3   13 0.6756596 0.04291652 0.2145826    7.428571           9  5.285714 #>    Max_depth #> T1         5 #> T2         7 #> T3         7"},{"path":"https://mspinillos.github.io/ecoregime/news/index.html","id":"ecoregime-012","dir":"Changelog","previous_headings":"","what":"ecoregime 0.1.2","title":"ecoregime 0.1.2","text":"Initial CRAN submission.","code":""}]
