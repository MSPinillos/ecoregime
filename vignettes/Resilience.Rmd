---
title: "Ecological resilience to pulse disturbances"
author: "Martina Sánchez-Pinillos"
output: 
  rmarkdown::html_vignette:
    toc: TRUE
vignette: >
  %\VignetteIndexEntry{Ecological resilience to pulse disturbances}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## 1. Introduction

### 1.1. Ecological resilience and the EDR framework

**Ecological resilience** is defined as the ability of ecological systems to tolerate disturbances and still maintain the same relationships between state variables (Holling, 1973). Measuring ecological resilience requires considering two important components: the dynamic trends of the system, including its cyclic behaviors, and the random forces representing positive and negative feedback relationships between the components of the system (Holling, 1973). As such, assessing ecological resilience must account for the system dynamic regimes. 

An **ecological dynamic regime (EDR)** is defined as the *fluctuations of an ecological system around some trend or average resulting from the interaction between internal processes and external forces that, in the absence of perturbations, keep the system within the basin of attraction* (Sánchez-Pinillos et al., 2023). The main dynamic trends characterizing an EDR are useful to identify cyclic behaviors and other more complex dynamics, such as transient dynamics. Additionally, the fluctuations and variability of ecological dynamics resulting from the interaction of multiple factors define the shape, size, and characteristics of dynamic regimes and potential domains of attraction (Sánchez-Pinillos et al., 2024).

The **EDR framework** is a set of algorithms and metrics to characterize and compare ecological dynamic regimes from empirical data so they can be used as the reference to assess ecological resilience accounting for both the dynamic trends of the system and the feedback relationships between its components.

To know more about the relevance of dynamic regimes for assessing ecological resilience, see this publication:

- Sánchez-Pinillos M., Dakos, V., Kéfi, S. 2024. Ecological dynamic regimes: A key concept for assessing ecological resilience. *Biological Conservation*. https://doi.org/10.1016/j.biocon.2023.110409

Additional information about the EDR framework can be found in this publication:

- Sánchez-Pinillos M., Kéfi, S., De Cáceres, M., Dakos, V. 2023. Ecological Dynamic Regimes: Identification, characterization, and comparison. *Ecological Monographs*. https://doi.org/10.1002/ecm.1589


### 1.2. About this vignette

This vignette aims to illustrate how ecological resilience can be assessed using the EDR framework implemented in `ecoregime`. In particular, this vignette focuses on the quantitative indices proposed in Sánchez-Pinillos et al. (2024) and their geometric rationale, taking ecological dynamic regimes as the reference to evaluate ecological resilience.

You can install `ecoregime` directly from CRAN or from my GitHub account (development version):

```{r install}
# install.packages("ecoregime")
# devtools::install_github(repo = "MSPinillos/ecoregime", dependencies = T, build_vignettes = T)
```

Once you have installed `ecoregime` you will have to load it:

```{r setup}
library(ecoregime)
```

```{r citation}
citation("ecoregime")
```

## 2. Assessing ecological dynamic regimes

### 2.1. Identifying the reference ecological dynamic regime

To assess the ecological resilience of a system, we need to identify its ecological dynamic regime (EDR) so it can be used as the reference to compare the disturbed dynamics. That is, the EDR to which the disturbed trajectories belonged before being disturbed. 

Given a stability landscape composed of alternative dynamic regimes, we can compute the dynamic dispersion (dDis) of the pre-disturbance portion of the disturbed trajectories in relation to each alternative EDR. The function `dDis()` allows us to quantify the degree of membership of any trajectory within an EDR. You can see more information about `dDis()` in `vignette("EDR_framework")`.

In the data included in `ecoregime` (i.e., `EDR_data`), you will find three abundance matrices corresponding to a set of community trajectories forming three ecological dynamic regimes (EDR1, EDR2, EDR3). Additionally, you will find an abundance matrix associated with three disturbed communities (`EDR3_disturbed`). Assuming that EDR1, EDR2, and EDR3 are three alternative dynamic regimes in a stability landscape, we will see how `dDis()` can be used to identify the EDR with which the disturbed trajectories are associated.

```{r dDis}
# Species abundances in undisturbed states of the disturbed trajectories
# (Undisturbed states are identified by disturbed_states = 0)
abun_undist <- EDR_data$EDR3_disturbed$abundance[disturbed_states == 0] 
selcols <- names(EDR_data$EDR1$abundance)

## EDR1 ------------------------------------------------------------------------

# Species abundances in EDR1 and the undisturbed states of disturbed trajectories
abun1_undist <- rbind(EDR_data$EDR1$abundance, abun_undist[, ..selcols])

# State dissimilarities in EDR1 and the undisturbed states of disturbed trajectories
d1_undist <- vegan::vegdist(x = abun1_undist[, paste0("sp", 1:12)], method = "bray")

# dDis of the disturbed trajectories in relation to EDR1
dDis1 <- sapply(unique(abun_undist$traj), function(iundist){
  dDis(d = d1_undist, d.type = "dStates", 
       trajectories = abun1_undist$traj, states = abun1_undist$state, 
       reference = as.character(iundist))
})

## EDR2 ------------------------------------------------------------------------

# Species abundances in EDR2 and the undisturbed states of disturbed trajectories
abun2_undist <- rbind(EDR_data$EDR2$abundance, abun_undist[, ..selcols])

# State dissimilarities in EDR2 and the undisturbed states of disturbed trajectories
d2_undist <- vegan::vegdist(x = abun2_undist[, paste0("sp", 1:12)], method = "bray")

# dDis of the disturbed trajectories in relation to EDR2
dDis2 <- sapply(unique(abun_undist$traj), function(iundist){
  dDis(d = d2_undist, d.type = "dStates", 
       trajectories = abun2_undist$traj, states = abun2_undist$state, 
       reference = as.character(iundist))
})

## EDR3 ------------------------------------------------------------------------

# Species abundances in EDR3 and the undisturbed states of disturbed trajectories
abun3_undist <- rbind(EDR_data$EDR3$abundance, abun_undist[, ..selcols])

# State dissimilarities in EDR3 and the undisturbed states of disturbed trajectories
d3_undist <- vegan::vegdist(x = abun3_undist[, paste0("sp", 1:12)], method = "bray")

# dDis of the disturbed trajectories in relation to EDR3
dDis3 <- sapply(unique(abun_undist$traj), function(iundist){
  dDis(d = d3_undist, d.type = "dStates", 
       trajectories = abun3_undist$traj, states = abun3_undist$state, 
       reference = as.character(iundist))
})

## Compare dynamic dispersion --------------------------------------------------

# Compare dDis values for the three EDRs
dDis_df <- data.frame(EDR1 = dDis1, EDR2 = dDis2, EDR3 = dDis3)

```

If we compare the values of dDis for each disturbed trajectory (ref. 31, ref. 32, ref. 33) and EDR (EDR1, EDR2, EDR3), we see that the lowest dDis values are associated with EDR3. We can take EDR3 as the reference to assess the ecological resilience of the three disturbed communities.

```{r dDis_comparison, echo=FALSE}
knitr::kable(dDis_df, digits = 3)

```

### 2.2. Define the main dynamic trends through representative trajectories

Once we have identified the EDR of reference, we can compute the representative trajectories using the function `retra_edr()`. See `vignette("EDR_framework")` for more information.

```{r retra}
# State dissimilarities for EDR3 (considering only the undisturbed trajectories)
d_EDR3 <- vegan::vegdist(EDR_data$EDR3$abundance[, paste0("sp", 1:12)])

# Representative trajectories
retra <- retra_edr(d = d_EDR3, 
                   trajectories = EDR_data$EDR3$abundance$traj,
                   states = EDR_data$EDR3$abundance$state, minSegs = 5)

```

Although there are five representative trajectories, we will select "T4" as the reference for being the longest and covering all regions of the EDR relatively well.

```{r summary_retra}
# Summarize retra
summary(retra)

# Define T4 as the unique representative trajectory and generate an object of class 'RETRA'
retra_ref <- define_retra(data = retra$T4$Segments, d = d_EDR3, 
                          trajectories = EDR_data$EDR3$abundance$traj, 
                          states = EDR_data$EDR3$abundance$state,
                          retra = retra)

```

```{r plot_retra, fig.dim = c(6,5)}
# Plot EDR3 and its representative trajectories
plot(retra, d = d_EDR3, 
     trajectories = EDR_data$EDR3$abundance$traj, 
     states = EDR_data$EDR3$abundance$state, select_RT = "T4",
     main = "Representative trajectories in EDR3")
legend("topleft", c("Representative trajectory 'T4'", 
                    "Other representative trajectories", 
                    "Individual trajectories in EDR3"),
       lty = 1, col = c("red", "black", "grey"), bty = "n")
```


## 3. Metrics of ecological resilience to pulse disturbances

When an ecological system is disturbed, its dynamics can deviate from the reference EDR and its representative trajectories. Depending on the immediate impact of the disturbance and the changes in the state variables following the release of the disturbance, post-disturbance trajectories can be characterized through four complementary indices: resistance (*Rt*), amplitude (*A*), recovery (*Rc*), and net change (*NC*).

```{r graphical_indices, echo=FALSE, fig.dim=c(6,5)}
par(mar = c(0,0,0,0))

# Representative trajectory
plot(x = 0:10, y = c(0,0,0:8), type = "n", axes = F, xlab = "", ylab = "")
for (i in 0:9) {
  shape::Arrows(x0 = i, y0 = 1, x1 = i + 1, y1 = 1, lwd = 2,  arr.adj = 1)
}
text(x = 0.2, y = 1.3, "RT")

# Reference
lines(x = c(0, 10), y = c(2.5, 2.5), col = RColorBrewer::brewer.pal(3, "Set1")[1], lty = 3, lwd = 2)

# Disturbed trajectory
for (i in 0.5:1.5) {
  shape::Arrows(x0 = i, y0 = 2.5, x1 = i + 1, y1 = 2.5, lwd = 2, arr.adj = 1,
                col = RColorBrewer::brewer.pal(3, "Set1")[1])
}
shape::Arrows(x0 = 2.5, y0 = 2.5, x1 = 4, y1 = 7, lwd = 2, arr.adj = 1,
              col = RColorBrewer::brewer.pal(3, "Set1")[1])
shape::Arrows(x0 = 4, y0 = 7, x1 = 5, y1 = 6, lwd = 2, arr.adj = 1,
              col = RColorBrewer::brewer.pal(3, "Set1")[1])
shape::Arrows(x0 = 5, y0 = 6, x1 = 5.5, y1 = 4, lwd = 2, arr.adj = 1,
              col = RColorBrewer::brewer.pal(3, "Set1")[1])
shape::Arrows(x0 = 5.5, y0 = 4, x1 = 6.5, y1 = 3.5, lwd = 2, arr.adj = 1,
              col = RColorBrewer::brewer.pal(3, "Set1")[1])
shape::Arrows(x0 = 6.5, y0 = 3.5, x1 = 7.5, y1 = 3.5, lwd = 2, arr.adj = 1,
              col = RColorBrewer::brewer.pal(3, "Set1")[1])
text(x = 0.7, y = 2.8, "DT", col = RColorBrewer::brewer.pal(3, "Set1")[1])

# Resistance
lines(x = c(2.5, 4)-0.2, y = c(2.5, 7), col = RColorBrewer::brewer.pal(3, "Set1")[2])
text(x = 2.8, y = 5, "Rt", col = RColorBrewer::brewer.pal(3, "Set1")[2])

# Amplitude
plotrix::draw.arc(x = 2.5, y = 2.5, radius = 0.7, angle1 = 0, deg2 = 70,
                  col = RColorBrewer::brewer.pal(3, "Set1")[3])
text(x = 3.3, y = 3.1, "A", col = RColorBrewer::brewer.pal(3, "Set1")[3])

# Recovery
lines(x = c(4, 5), y = c(7, 7), lty = 3, lwd = 2, 
      col = RColorBrewer::brewer.pal(4, "Set1")[4])
plotrix::draw.arc(x = 4, y = 7, radius = 0.6, deg1 = 0, deg2 = -45,
                  col = RColorBrewer::brewer.pal(4, "Set1")[4])
text(x = 4.9, y = 6.7, "Rc", col = RColorBrewer::brewer.pal(4, "Set1")[4])

# Net change
lines(x = c(2.5, 6.5), y = c(2.5, 3.5), lty = 3, lwd = 2,
      col = RColorBrewer::brewer.pal(9, "Set1")[9])
plotrix::draw.arc(x = 2.5, y = 2.5, radius = 1.5, angle1 = 0, deg2 = 15,
                  col = RColorBrewer::brewer.pal(9, "Set1")[9])
text(x = 4.3, y = 2.7, "NC", col = RColorBrewer::brewer.pal(9, "Set1")[9])

# Legend
legend("topright",
       c("RT: Representative trajectory",
         "DT: Disturbed trajectory",
         "Rt: Resistance",
         "A: Amplitude",
         "Rc: Recovery",
         "NC: Net change"),
       col = c("black", RColorBrewer::brewer.pal(9, "Set1")[c(1:4, 9)]),
       lty = 1, text.col = c("black", RColorBrewer::brewer.pal(9, "Set1")[c(1:4, 9)]), bty = "n")

# States
text(x = c(2.5, 4, 5.2, 5.3, 6.5, 7.5), y = c(2.2, 7.4, 6, 4, 3.8, 3.8),
     0:5, cex = 0.9, col = RColorBrewer::brewer.pal(5, "Set1")[1])

```

### 3.1. Resistance

The resistance index (*Rt*) quantifies the impact of the disturbance on the system based on the immediate changes in the state variables. That is, it is a measure of how similar the disturbed (1) and the pre-disturbance (0) states are (Sánchez-Pinillos et al., 2019). As such, the resistance index does not depend on the position of the system within the EDR.

$$Rt = 1 - d_{pre, dist}$$

where $d_{pre,dist}$ is the dissimilarity between the pre-disturbance (0) and the disturbed (1) states.


```{r graphical_resistance, echo=FALSE, fig.dim=c(6,5)}

par(mar = c(0,0,0,0))

# Representative trajectory
plot(x = c(0, 10), y = c(0, 4.5), type = "n", axes = F, xlab = "", ylab = "")
for (i in 0:9) {
  shape::Arrows(x0 = i, y0 = 0, x1 = i + 1, y1 = 0, lwd = 2,  arr.adj = 1)
}
text(x = 0.2, y = 0.2, "RT")

# Reference
lines(x = c(0, 10), y = c(2.5, 2.5), col = RColorBrewer::brewer.pal(3, "Set1")[1], lty = 3, lwd = 2)

# Disturbed trajectories
for (i in 5.5:6.5) {
  shape::Arrows(x0 = i, y0 = 2.5, x1 = i + 1, y1 = 2.5, lwd = 2, arr.adj = 1,
                col = RColorBrewer::brewer.pal(3, "Set1")[1])
}
shape::Arrows(x0 = 7.5, y0 = 2.5, x1 = 8.5, y1 = 4, lwd = 2, arr.adj = 1,
              col = RColorBrewer::brewer.pal(3, "Set1")[1])
text(x = 5.7, y = 2.7, "DT2", col = RColorBrewer::brewer.pal(3, "Set1")[1])

for (i in 0.5:1.5) {
  shape::Arrows(x0 = i, y0 = 2.5, x1 = i + 1, y1 = 2.5, lwd = 2, arr.adj = 1,
                col = RColorBrewer::brewer.pal(3, "Set1")[1])
}
shape::Arrows(x0 = 2.5, y0 = 2.5, x1 = 8, y1 = 1, lwd = 2, arr.adj = 1,
              col = RColorBrewer::brewer.pal(3, "Set1")[1])
text(x = 0.7, y = 2.7, "DT1", col = RColorBrewer::brewer.pal(3, "Set1")[1])


# Resistance
lines(x = c(7.5, 8.5)-0.2, y = c(2.5, 4)+0.05, lwd = 2, col = RColorBrewer::brewer.pal(3, "Set1")[2])
text(x = 7.2, y = 3.4, "High Rt", col = RColorBrewer::brewer.pal(3, "Set1")[2])
lines(x = c(2.5, 8)-0.1, y = c(2.5, 1)-0.2, lwd = 2, col = RColorBrewer::brewer.pal(3, "Set1")[2])
text(x = 5, y = 1.3, "Low Rt", col = RColorBrewer::brewer.pal(3, "Set1")[2])


# Legend
legend("topleft",
       c("RT: Representative trajectory",
         "DT: Disturbed trajectories",
         "Rt: Resistance"),
       col = c("black", RColorBrewer::brewer.pal(5, "Set1")),
       lty = 1, text.col = c("black", RColorBrewer::brewer.pal(5, "Set1")), bty = "n")

# States
text(x = c(2.5, 7.5, 8.7, 8.3), y = c(2.7, 2.3, 4.2, 1),
     c(0, 0, 1, 1), cex = 0.9, col = RColorBrewer::brewer.pal(5, "Set1")[1])

```

Given the three disturbed trajectories in EDR3 (i.e., `EDR3_disturbed`), we can compute the resistance index using the function `resistance()`:

```{r resistance}
# To calculate resistance, we need a state dissimilarity matrix for the disturbed trajectories
d_disturbed <- vegan::vegdist(EDR_data$EDR3_disturbed$abundance[, paste0("sp", 1:12)], 
                              method = "bray")

# Compute resistance
# Note that the disturbed states are identified by disturbed_states = 1
Rt <- resistance(d = d_disturbed, 
                 trajectories = EDR_data$EDR3_disturbed$abundance$traj, 
                 states = EDR_data$EDR3_disturbed$abundance$state, 
                 disturbed_trajectories = unique(EDR_data$EDR3_disturbed$abundance$traj), 
                 disturbed_states = EDR_data$EDR3_disturbed$abundance[disturbed_states == 1]$state)

```

The three hypothetical systems show a relatively high resistance (close to 1) to the disturbance:

```{r Rt_results, echo=FALSE}
knitr::kable(Rt, row.names = F, col.names = c("Disturbed trajectories", "Rt"), digits = 3)
```

### 3.2. Amplitude

The amplitude (*A*) quantifies how much the system is deviated from its trajectory during the disturbance assuming that, in the absence of disturbances, the system would keep a constant distance to a representative trajectory taken as the reference.

The amplitude can be calculated in absolute terms as the difference of the dissimilarity between the disturbed state (1) and the representative trajectory ($d_{dist,RT}$) and the dissimilarity between the pre-disturbance state (0) and the representative trajectory ($d_{pre,RT}$):

$$A_{abs} = d_{dist,RT} - d_{pre,RT}$$

Alternatively, the amplitude can be calculated in relation to the impact of the disturbance ($d_{pre,dist}$). In this case, the amplitude quantifies the ability of the system to remain close to the representative trajectory in relation to the changes in the state variables provoked by the disturbance.

$$A_{rel} = \frac{d_{dist,RT} - d_{pre,RT}}{d_{pre,dist}}$$

In any case, positive amplitude values indicate that the system is deviated towards the boundaries of the EDR, whereas negative values indicate the deviation towards the representative trajectory taken as the reference.

```{r graphical_amplitude, echo=FALSE, fig.dim=c(6,5)}

par(mar = c(0,0,0,0))

# Representative trajectory
plot(x = c(0, 16), y = c(0, 5.5), type = "n", axes = F, xlab = "", ylab = "")
for (i in 0:14) {
  shape::Arrows(x0 = i, y0 = 0, x1 = i + 1, y1 = 0, lwd = 2, arr.adj = 1)
}
text(x = 0.2, y = 0.2, "RT")

# Reference
lines(x = c(0, 15), y = c(2.5, 2.5), col = RColorBrewer::brewer.pal(3, "Set1")[1], lty = 3, lwd = 2)

# Disturbed trajectory 1
for (i in 0.5:1.5) {
  shape::Arrows(x0 = i, y0 = 2.5, x1 = i + 1, y1 = 2.5, lwd = 2, arr.adj = 1,
                col = RColorBrewer::brewer.pal(3, "Set1")[1])
}
shape::Arrows(x0 = 2.5, y0 = 2.5, x1 = 4, y1 = 0.5, lwd = 2, arr.adj = 1,
              col = RColorBrewer::brewer.pal(3, "Set1")[1])
text(x = 0.7, y = 2.7, "DT1", col = RColorBrewer::brewer.pal(3, "Set1")[1])

# Disturbed trajectory 2
for (i in 5:6) {
  shape::Arrows(x0 = i, y0 = 2.5, x1 = i + 1, y1 = 2.5, lwd = 2, arr.adj = 1,
                col = RColorBrewer::brewer.pal(3, "Set1")[1])
}
shape::Arrows(x0 = 7, y0 = 2.5, x1 = 14, y1 = 4.5, lwd = 2, arr.adj = 1,
              col = RColorBrewer::brewer.pal(3, "Set1")[1])
text(x = 5, y = 2.7, "DT2", col = RColorBrewer::brewer.pal(3, "Set1")[1])



# # Amplitude
lines(x = c(4, 4), y = c(0.5, 2.5), lwd = 2, col = RColorBrewer::brewer.pal(5, "Set1")[3])
text(x = 5, y = 1.5, expression(A[abs1] ~ "< 0"), col = RColorBrewer::brewer.pal(5, "Set1")[3])
plotrix::draw.arc(x = 2.5, y = 2.5, radius = 0.5, deg2 = -70, lwd = 2, col = RColorBrewer::brewer.pal(5, "Set1")[3])
text(x = 3.8, y = 2.2, expression(A[rel1] ~ "< 0"), col = RColorBrewer::brewer.pal(5, "Set1")[3])

lines(x = c(14, 14), y = c(2.5, 4.5), lwd = 2, col = RColorBrewer::brewer.pal(5, "Set1")[3])
text(x = 15, y = 3.5, expression(A[abs2] ~ "> 0"), col = RColorBrewer::brewer.pal(5, "Set1")[3])
plotrix::draw.arc(x = 7, y = 2.5, radius = 1.5, deg2 = 32, lwd = 2, col = RColorBrewer::brewer.pal(5, "Set1")[3])
text(x = 9.5, y = 2.75, expression(A[rel2] ~ "> 0"), col = RColorBrewer::brewer.pal(5, "Set1")[3])

text(x = c(0), y = c(4.5), adj = 0, expression("|"~A[abs1]~"| = |"~A[abs2]~"|"), cex = 0.9, 
     col = RColorBrewer::brewer.pal(5, "Set1")[3])
text(x = c(0), y = c(4.2), adj = 0, expression("|"~A[rel1]~"| > |"~A[rel2]~"|"), cex = 0.9, 
     col = RColorBrewer::brewer.pal(5, "Set1")[3])

# Legend
legend("topleft",
       c("RT: Representative trajectory",
         "DT: Disturbed trajectories",
         "A: Amplitude"),
       col = c("black", RColorBrewer::brewer.pal(5, "Set1")[c(1, 3)]),
       lty = 1, text.col = c("black", RColorBrewer::brewer.pal(5, "Set1")[c(1, 3)]), bty = "n")

# States
text(x = c(2.5, 7, 4, 14), y = c(2.7, 2.3, 0.3, 4.7),
     c(0, 0, 1, 1), cex = 0.9, col = RColorBrewer::brewer.pal(5, "Set1")[1])

```

Amplitude can be calculated using the function `amplitude()`:

```{r amplitude}
# We need a state dissimilarity matrix containing the states of the disturbed 
# trajectories and the representative trajectory taken as the reference
abun <- rbind(EDR_data$EDR3$abundance, EDR_data$EDR3_disturbed$abundance, fill = T)
d <- vegan::vegdist(abun[, paste0("sp", 1:12)], method = "bray")

# Compute amplitude
A <- amplitude(d = d,
               trajectories = abun$traj,
               states = abun$state,
               disturbed_trajectories = abun[disturbed_states == 1]$traj,
               disturbed_states = abun[disturbed_states == 1]$state,
               reference = retra_ref, method = "nearest_state")

```

The three considered systems show positive amplitude values, indicating that the disturbance lead them towards the boundaries of the EDR. Whereas the absolute amplitude of trajectory 31 ($A_{abs}(31) = 0.027$) is smaller than the absolute amplitude of trajectory 32 ($A_{rel}(32) = 0.119$), both have similar relative values ($A_{rel}(31) = 0.653$; $A_{rel}(32) = 0.631$). This result indicates that despite the small deviation of trajectory 31 from the representative trajectory during the disturbance, such deviation is disproportionately high in relation to the impact of the disturbance on the state variables.

```{r A_results, echo=FALSE}
knitr::kable(A, col.names = c("Disturbed trajectories", "Reference", "A~abs~", "A~rel~"), digits = 3)
```

### 3.3. Recovery

The recovery index (*Rc*) quantifies the ability of the system to reorganize itself after a disturbance and evolve towards the representative trajectory representing its dominant dynamic trends.

The recovery can be calculated in absolute terms as the difference of the dissimilarity between the disturbed state (1) and the representative trajectory ($d_{dist,RT}$) and the dissimilarity between one of the post-disturbance states (> 1) and the representative trajectory ($d_{post,RT}$):

$$Rc_{abs} = d_{dist,RT} - d_{post,RT}$$

Alternatively, the recovery can be calculated in relation to the changes in the state variables that the system must perform to return towards the representative trajectory from the disturbed state ($d_{dist, post}$). In this case, the index penalizes the systems that require major restructuring of the state variables to return towards the representative trajectory (positive recovery) and gives less negative values to the systems minimizing the escape from the dynamic regime through major changes in its state variables.

$$Rc_{rel} = \frac{d_{dist,RT} - d_{post,RT}}{d_{dist, post}}$$

Both absolute and relative recovery indices are positive when the system evolves towards the representative trajectory. Otherwise, negative values indicate that the system evolves towards the boundaries of the EDR.

```{r graphical_recovery, echo=FALSE, fig.dim=c(6,5)}

par(mar = c(0,0,0,0))

# Representative trajectory
plot(x = c(0, 16), y = c(0, 5.5), type = "n", axes = F, xlab = "", ylab = "")
for (i in 0:14) {
  shape::Arrows(x0 = i, y0 = 1, x1 = i + 1, y1 = 1, lwd = 2, arr.adj = 1)
}
text(x = 0.2, y = 1.2, "RT")

# Reference
lines(x = c(0, 15), y = c(2.5, 2.5), col = RColorBrewer::brewer.pal(3, "Set1")[1], lty = 3, lwd = 2)

# Disturbed trajectory 1
for (i in 0.5:1.5) {
  shape::Arrows(x0 = i, y0 = 2.5, x1 = i + 1, y1 = 2.5, lwd = 2, arr.adj = 1,
                col = RColorBrewer::brewer.pal(3, "Set1")[1])
}
shape::Arrows(x0 = 2.5, y0 = 2.5, x1 = 4, y1 = 4.5, lwd = 2, arr.adj = 1,
              col = RColorBrewer::brewer.pal(3, "Set1")[1])
shape::Arrows(x0 = 4, y0 = 4.5, x1 = 5, y1 = 3.5, lwd = 2, arr.adj = 1,
              col = RColorBrewer::brewer.pal(3, "Set1")[1])
text(x = 0.7, y = 2.7, "DT1", col = RColorBrewer::brewer.pal(3, "Set1")[1])

# Disturbed trajectory 2
for (i in 6:7) {
  shape::Arrows(x0 = i, y0 = 2.5, x1 = i + 1, y1 = 2.5, lwd = 2, arr.adj = 1,
                col = RColorBrewer::brewer.pal(3, "Set1")[1])
}
shape::Arrows(x0 = 8, y0 = 2.5, x1 = 9.5, y1 = 4.5, lwd = 2, arr.adj = 1,
              col = RColorBrewer::brewer.pal(3, "Set1")[1])
shape::Arrows(x0 = 9.5, y0 = 4.5, x1 = 14, y1 = 3.5, lwd = 2, arr.adj = 1,
              col = RColorBrewer::brewer.pal(3, "Set1")[1])
text(x = 6.2, y = 2.7, "DT2", col = RColorBrewer::brewer.pal(3, "Set1")[1])

# States
text(x = c(2.5, 3.5, 5, 8, 9.5, 14), y = c(2.3, 4.5, 3.3, 2.3, 4.7, 3.3),
     c(0:2, 0:2), cex = 0.9, col = RColorBrewer::brewer.pal(5, "Set1")[1])


# Recovery DT1
lines(x = c(4, 5), y = c(4.5, 4.5), lty = 3, col = RColorBrewer::brewer.pal(5, "Set1")[4])
lines(x = c(5, 5), y = c(3.5, 4.5), lwd = 2, col = RColorBrewer::brewer.pal(5, "Set1")[4])
text(x = 5.2, y = 4, adj = 0, expression(Rc[abs1] ~ "> 0"), col = RColorBrewer::brewer.pal(5, "Set1")[4])

# lines(x = c(4, 4), y = c(3.5, 4.5), lty = 3, col = RColorBrewer::brewer.pal(5, "Set1")[4])
plotrix::draw.arc(x = 4, y = 4.5, radius = 0.5, deg1 = 0, deg2 = -65, lwd = 2, col = RColorBrewer::brewer.pal(5, "Set1")[4])
text(x = 4, y = 4.7, adj = 0, expression(Rc[rel1] ~ "> 0"), col = RColorBrewer::brewer.pal(5, "Set1")[4])

# Recovery DT2
lines(x = c(9.5, 14), y = c(4.5, 4.5), lty = 3, col = RColorBrewer::brewer.pal(5, "Set1")[4])
lines(x = c(14, 14), y = c(3.5, 4.5), lwd = 2, col = RColorBrewer::brewer.pal(5, "Set1")[4])
text(x = 15, y = 4, expression(Rc[abs2] ~ "> 0"), col = RColorBrewer::brewer.pal(5, "Set1")[4])

# lines(x = c(9.5, 9.5), y = c(3.5, 4.5), lty = 3, col = RColorBrewer::brewer.pal(5, "Set1")[4])
plotrix::draw.arc(x = 9.5, y = 4.5, radius = 1, deg1 = 0, deg2 = -25, lwd = 2, col = RColorBrewer::brewer.pal(5, "Set1")[4])
text(x = 11, y = 4.3, adj = 0, expression(Rc[rel2] ~ "> 0"), col = RColorBrewer::brewer.pal(5, "Set1")[4])

text(x = c(0), y = c(4.5), adj = 0, expression(Rc[abs1]~" = "~Rc[abs2]), cex = 0.9, 
     col = RColorBrewer::brewer.pal(5, "Set1")[4])
text(x = c(0), y = c(4.2), adj = 0, expression(Rc[rel1]~" > "~Rc[rel2]), cex = 0.9, 
     col = RColorBrewer::brewer.pal(5, "Set1")[4])

# Legend
legend("topleft",
       c("RT: Representative trajectory",
         "DT: Disturbed trajectories",
         "Rc: Recovery"),
       col = c("black", RColorBrewer::brewer.pal(5, "Set1")[c(1, 4)]),
       lty = 1, text.col = c("black", RColorBrewer::brewer.pal(5, "Set1")[c(1, 4)]), bty = "n")


```

```{r graphical_recovery2, echo=FALSE, fig.dim=c(6,5)}

par(mar = c(0,0,0,0))

# Representative trajectory
plot(x = c(0, 16), y = c(0, 5.5), type = "n", axes = F, xlab = "", ylab = "")
for (i in 0:14) {
  shape::Arrows(x0 = i, y0 = 0, x1 = i + 1, y1 = 0, lwd = 2, arr.adj = 1)
}
text(x = 0.2, y = 0.2, "RT")

# Reference
lines(x = c(0, 15), y = c(2.5, 2.5), col = RColorBrewer::brewer.pal(3, "Set1")[1], lty = 3, lwd = 2)

# Disturbed trajectory 3
for (i in 0.5:1.5) {
  shape::Arrows(x0 = i, y0 = 2.5, x1 = i + 1, y1 = 2.5, lwd = 2, arr.adj = 1,
                col = RColorBrewer::brewer.pal(3, "Set1")[1])
}
shape::Arrows(x0 = 2.5, y0 = 2.5, x1 = 4, y1 = 0.5, lwd = 2, arr.adj = 1,
              col = RColorBrewer::brewer.pal(3, "Set1")[1])
shape::Arrows(x0 = 4, y0 = 0.5, x1 = 5, y1 = 1.5, lwd = 2, arr.adj = 1,
              col = RColorBrewer::brewer.pal(3, "Set1")[1])
text(x = 0.7, y = 2.7, "DT3", col = RColorBrewer::brewer.pal(3, "Set1")[1])

# Disturbed trajectory 4
for (i in 6:7) {
  shape::Arrows(x0 = i, y0 = 2.5, x1 = i + 1, y1 = 2.5, lwd = 2, arr.adj = 1,
                col = RColorBrewer::brewer.pal(3, "Set1")[1])
}
shape::Arrows(x0 = 8, y0 = 2.5, x1 = 9.5, y1 = 4.5, lwd = 2, arr.adj = 1,
              col = RColorBrewer::brewer.pal(3, "Set1")[1])
shape::Arrows(x0 = 9.5, y0 = 4.5, x1 = 14, y1 = 5.5, lwd = 2, arr.adj = 1,
              col = RColorBrewer::brewer.pal(3, "Set1")[1])
text(x = 6.2, y = 2.7, "DT4", col = RColorBrewer::brewer.pal(3, "Set1")[1])

# States
text(x = c(2.5, 3.4, 5.5, 8, 9.2, 14.2), y = c(2.7, 0.6, 1.5, 2.3, 4.5, 5.6),
     c(0:2, 0:2), cex = 0.9, col = RColorBrewer::brewer.pal(5, "Set1")[1])


# Recovery DT3
lines(x = c(4, 5), y = c(0.5, 0.5), lty = 3, col = RColorBrewer::brewer.pal(5, "Set1")[4])
lines(x = c(5, 5), y = c(0.5, 1.5), lwd = 2, col = RColorBrewer::brewer.pal(5, "Set1")[4])
text(x = 5.2, y = 1, adj = 0, expression(Rc[abs3] ~ "< 0"), col = RColorBrewer::brewer.pal(5, "Set1")[4])

# lines(x = c(4, 4), y = c(0.5, 1.5), lty = 3, col = RColorBrewer::brewer.pal(5, "Set1")[4])
plotrix::draw.arc(x = 4, y = 0.5, radius = 0.5, deg1 = 0, deg2 = 65, lwd = 2, col = RColorBrewer::brewer.pal(5, "Set1")[4])
text(x = 3.8, y = 0.3, adj = 0, expression(Rc[rel3] ~ "< 0"), col = RColorBrewer::brewer.pal(5, "Set1")[4])

# Recovery DT4
lines(x = c(9.5, 14), y = c(4.5, 4.5), lty = 3, col = RColorBrewer::brewer.pal(5, "Set1")[4])
lines(x = c(14, 14), y = c(5.5, 4.5), lwd = 2, col = RColorBrewer::brewer.pal(5, "Set1")[4])
text(x = 15, y = 5, expression(Rc[abs4] ~ "< 0"), col = RColorBrewer::brewer.pal(5, "Set1")[4])

# lines(x = c(9.5, 9.5), y = c(5.5, 4.5), lty = 3, col = RColorBrewer::brewer.pal(5, "Set1")[4])
plotrix::draw.arc(x = 9.5, y = 4.5, radius = 1.3, deg1 = 0, deg2 = 25, lwd = 2, col = RColorBrewer::brewer.pal(5, "Set1")[4])
text(x = 11.1, y = 4.7, adj = 0, expression(Rc[rel4] ~ "< 0"), col = RColorBrewer::brewer.pal(5, "Set1")[4])

text(x = c(0), y = c(5.5), adj = 0, expression(Rc[abs3]~" = "~Rc[abs4]), cex = 0.9, 
     col = RColorBrewer::brewer.pal(5, "Set1")[4])
text(x = c(0), y = c(5.2), adj = 0, expression(Rc[rel3]~" < "~Rc[rel4]~" < "~Rc[rel2]~" < "~Rc[rel1]), cex = 0.9, 
     col = RColorBrewer::brewer.pal(5, "Set1")[4])


```

Recovery can be calculated using the function `recovery()` considering all states after the disturbed state (> 1):

```{r recovery}
# Compute recovery using the same data used for amplitude
Rc <- recovery(d = d, 
               trajectories = abun$traj,
               states = abun$state, 
               disturbed_trajectories = abun[disturbed_states == 1]$traj,
               disturbed_states = abun[disturbed_states == 1]$state, 
               reference = retra_ref, method = "nearest_state")

```

We can plot the variation of recovery over time considering all post-disturbance states:

```{r plot_recovery, fig.dim=c(6,5)}
# Number of states after the disturbed state
Rc <- data.table::data.table(Rc)
Rc[, ID_post := 1:(.N), by = disturbed_trajectories]

# Plot absolute recovery over time
plot(x = range(Rc$ID_post), y = range(Rc$Rc_abs), type = "n",
     xlab = "Nb. states after disturbance", ylab = "Absolute recovery",
     main = "Variation of absolute recovery")
for (i in unique(Rc$disturbed_trajectories)) {
  lines(Rc[disturbed_trajectories == i, c("ID_post", "Rc_abs")],
        col = which(unique(Rc$disturbed_trajectories) %in% i) + 1)
}
legend("bottomleft", legend = unique(Rc$disturbed_trajectories), lty = 1, 
       col = seq_along(unique(Rc$disturbed_trajectories)) + 1, bty = "n")

# Plot relative recovery over time
plot(x = range(Rc$ID_post), y = range(Rc$Rc_rel), type = "n",
     xlab = "Nb. states after disturbance", ylab = "Relative recovery",
     main = "Variation of relative recovery")
for (i in unique(Rc$disturbed_trajectories)) {
  lines(Rc[disturbed_trajectories == i, c("ID_post", "Rc_rel")],
        col = which(unique(Rc$disturbed_trajectories) %in% i) + 1)
}
legend("topright", legend = unique(Rc$disturbed_trajectories), lty = 1, 
       col = seq_along(unique(Rc$disturbed_trajectories)) + 1, bty = "n")



```

### 3.4. Net change

Net change (*NC*) quantifies how much the system is deviated from its trajectory after the release of the disturbance assuming that, in the absence of disturbances, the system would keep a constant distance to a representative trajectory taken as the reference.

Like amplitude and recovery, net change can be calculated in absolute or relative terms. The absolute net change is expressed as the difference of the dissimilarity between one of the post-disturbance states (> 1) and the representative trajectory ($d_{post,RT}$) and the dissimilarity between the pre-disturbance state (0) and the representative trajectory ($d_{pre,RT}$):

$$NC_{abs} = d_{post,RT} - d_{pre,RT}$$

The relative net change is calculated in relation to the changes produced in the state variables between the pre-disturbance and the post-disturbance states ($d_{pre,post}$). In this way, the index penalizes the systems that deviated from the expected trajectory despite being very similar to the pre-disturbance state.

$$NC_{rel} = \frac{d_{post,RT} - d_{pre,RT}}{d_{pre,post}}$$

As in the amplitude index, positive values indicate that the system is deviated towards the boundaries of the EDR and negative values indicate the deviation towards the representative trajectory taken as the reference.

```{r graphical_NetChange, echo=FALSE, fig.dim=c(6,5)}

par(mar = c(0,0,0,0))

# Representative trajectory
plot(x = c(0, 16), y = c(0, 5.5), type = "n", axes = F, xlab = "", ylab = "")
for (i in 0:14) {
  shape::Arrows(x0 = i, y0 = 1, x1 = i + 1, y1 = 1, lwd = 2, arr.adj = 1)
}
text(x = 0.2, y = 1.2, "RT")

# Reference
lines(x = c(0, 15), y = c(2.5, 2.5), col = RColorBrewer::brewer.pal(3, "Set1")[1], lty = 3, lwd = 2)

# Disturbed trajectory 1
for (i in 0.5:1.5) {
  shape::Arrows(x0 = i, y0 = 2.5, x1 = i + 1, y1 = 2.5, lwd = 2, arr.adj = 1,
                col = RColorBrewer::brewer.pal(3, "Set1")[1])
}
shape::Arrows(x0 = 2.5, y0 = 2.5, x1 = 4, y1 = 4.5, lwd = 2, arr.adj = 1,
              col = RColorBrewer::brewer.pal(3, "Set1")[1])
shape::Arrows(x0 = 4, y0 = 4.5, x1 = 5, y1 = 3.5, lwd = 2, arr.adj = 1,
              col = RColorBrewer::brewer.pal(3, "Set1")[1])
text(x = 0.7, y = 2.7, "DT1", col = RColorBrewer::brewer.pal(3, "Set1")[1])

# Disturbed trajectory 2
for (i in 6:7) {
  shape::Arrows(x0 = i, y0 = 2.5, x1 = i + 1, y1 = 2.5, lwd = 2, arr.adj = 1,
                col = RColorBrewer::brewer.pal(3, "Set1")[1])
}
shape::Arrows(x0 = 8, y0 = 2.5, x1 = 9.5, y1 = 3.5, lwd = 2, arr.adj = 1,
              col = RColorBrewer::brewer.pal(3, "Set1")[1])
shape::Arrows(x0 = 9.5, y0 = 3.5, x1 = 14, y1 = 1.5, lwd = 2, arr.adj = 1,
              col = RColorBrewer::brewer.pal(3, "Set1")[1])
text(x = 6.2, y = 2.7, "DT2", col = RColorBrewer::brewer.pal(3, "Set1")[1])

# States
text(x = c(2.5, 4, 5.5, 8, 9.5, 14), y = c(2.3, 4.7, 3.5, 2.3, 3.7, 1.3),
     c(0:2, 0:2), cex = 0.9, col = RColorBrewer::brewer.pal(5, "Set1")[1])


# Net change DT1
lines(x = c(2.5, 5), y = c(2.5, 3.5), lty = 3, col = RColorBrewer::brewer.pal(9, "Set1")[9])
lines(x = c(5, 5), y = c(2.5, 3.5), lwd = 2, col = RColorBrewer::brewer.pal(9, "Set1")[9])
text(x = 5.2, y = 3, adj = 0, expression(NC[abs1] ~ "> 0"), col = RColorBrewer::brewer.pal(9, "Set1")[9])

plotrix::draw.arc(x = 2.5, y = 2.5, radius = 0.6, deg2 = 40, lwd = 2, col = RColorBrewer::brewer.pal(9, "Set1")[9])
text(x = 3.2, y = 2.7, adj = 0, expression(NC[rel1] ~ "> 0"), col = RColorBrewer::brewer.pal(9, "Set1")[9])

# Net change DT2
lines(x = c(8, 14), y = c(2.5, 1.5), lty = 3, col = RColorBrewer::brewer.pal(9, "Set1")[9])
lines(x = c(14, 14), y = c(2.5, 1.5), lwd = 2, col = RColorBrewer::brewer.pal(9, "Set1")[9])
text(x = 15, y = 2, expression(NC[abs2] ~ "< 0"), col = RColorBrewer::brewer.pal(9, "Set1")[9])

plotrix::draw.arc(x = 8, y = 2.5, radius = 1.7, deg2 = -20, lwd = 2, col = RColorBrewer::brewer.pal(9, "Set1")[9])
text(x = 10, y = 2.3, adj = 0, expression(NC[rel2] ~ "< 0"), col = RColorBrewer::brewer.pal(9, "Set1")[9])

text(x = c(0), y = c(4.5), adj = 0, expression("|"~NC[abs1]~"| = |"~NC[abs2]~"|"), cex = 0.9, 
     col = RColorBrewer::brewer.pal(9, "Set1")[9])
text(x = c(0), y = c(4.2), adj = 0, expression("|"~NC[rel1]~"| > |"~NC[rel2]~"|"), cex = 0.9, 
     col = RColorBrewer::brewer.pal(9, "Set1")[9])

# Legend
legend("topleft",
       c("RT: Representative trajectory",
         "DT: Disturbed trajectories",
         "NC: Net change"),
       col = c("black", RColorBrewer::brewer.pal(9, "Set1")[c(1, 9)]),
       lty = 1, text.col = c("black", RColorBrewer::brewer.pal(9, "Set1")[c(1, 9)]), bty = "n")


```

The function `net_change()` included in `ecoregime` can be used to calculate the net change of all post-disturbance states in relation to the pre-disturbance state:

```{r net_change}
# Compute net change using the same data used for amplitude
NC <- net_change(d = d, 
                 trajectories = abun$traj,
                 states = abun$state,
                 disturbed_trajectories = abun[disturbed_states == 1]$traj,
                 disturbed_states = abun[disturbed_states == 1]$state,
                 reference = retra_ref, method = "nearest_state")

```

We can plot the variation of net change over time considering all post-disturbance states:

```{r plot_NetChange, fig.dim=c(6,5)}
# ID post-disturbance states
NC <- data.table::data.table(NC)
NC[, ID_post := 1:(.N), by = disturbed_trajectories]

# Plot absolute net change over time
plot(x = range(NC$ID_post), y = range(NC$NC_abs), type = "n",
     xlab = "Nb. states after disturbance", ylab = "Absolute net change",
     main = "Variation of absolute net change")
for (i in unique(NC$disturbed_trajectories)) {
  lines(NC[disturbed_trajectories == i, c("ID_post", "NC_abs")],
        col = which(unique(NC$disturbed_trajectories) %in% i) + 1)
}
legend("topleft", legend = unique(NC$disturbed_trajectories), lty = 1, 
       col = seq_along(unique(NC$disturbed_trajectories)) + 1, bty = "n")

# Plot relative net change over time
plot(x = range(NC$ID_post), y = range(NC$NC_rel), type = "n",
     xlab = "Nb. states after disturbance", ylab = "Relative net change",
     main = "Variation of relative net change")
for (i in unique(NC$disturbed_trajectories)) {
  lines(NC[disturbed_trajectories == i, c("ID_post", "NC_rel")],
        col = which(unique(NC$disturbed_trajectories) %in% i) + 1)
}
legend("bottomleft", legend = unique(NC$disturbed_trajectories), lty = 1, 
       col = seq_along(unique(NC$disturbed_trajectories)) + 1, bty = "n")

```


## 4. Assessing the ecological resilience of systems affected by pulse disturbances

Altogether, the metrics of amplitude, recovery, and net change define the geometry of disturbed trajectories in relation to the reference EDR. Additionally, the resistance index helps interpret the response of the system considering the immediate impact of the disturbance.

As an example, we will take the three disturbed trajectories used in the previous section. For simplicity, we will only focus on resistance and the absolute values of amplitude, recovery, and net change and we will consider the 14th post-disturbance state (last post-disturbance state of *Trajectory 33*) of all trajectories to calculate recovery and net change.

```{r A_Rc_NC}
# Merge the results for resistance, amplitude, recovery, and net change
results <- Reduce(function(x, y) merge(x, y, all = T),
                  list(Rt, A, Rc, NC))
results <- results[which(results$ID_post == 14), 
                   c("disturbed_trajectories", "Rt", "A_abs", "Rc_abs", "NC_abs")]
```

```{r all_results, echo=FALSE}
knitr::kable(results, row.names = F, digits = 3, 
             col.names = c("Disturbed trajectories", "Rt", "A~abs~", "Rc~abs~", "NC~abs~"))
```

Based on the values of the indices, we can figure out the shape of the disturbed trajectories. For example, *Trajectory 31* was very resistant to the immediate impact of the disturbance (in terms of changes in the state variables) ($Rt = 0.958$) and the amplitude provoked by the disturbance was very small ($A = 0.027$). However, unlike *Trajectory 32* and *Trajectory 33*, the recovery was negative ($Rc = -0.474$) and the net change positive and relatively high ($NC = 0.502$). Thus, despite the relatively low impact of the disturbance, the values of recovery and net change indicate that *Trajectory 31* goes away from the reference EDR and the system potentially changes to an alternative dynamic regime.

Both *Trajectory 32* and *Trajectory 33* showed positive values of recovery and net change values close to zero. In both cases, amplitude and recovery have similar values, respectively (*Trajectory 32:* $A = 0.119$, $Rc = 0.099$; *Trajectory 33:* $A = 0.268$, $Rc = 0.283$), indicating that these systems are able to reorganize and remain within the EDR. 

*Trajectory 32* was relatively resistant to the impact of the disturbance ($Rt = 0.812$) and showed a relatively low deviation from the representative trajectory ($A = 0.119$). In contrast, *Trajectory 33* was more severely impacted by the disturbance ($Rt = 0.693$; $A = 0.268$) but showed a high recovery capacity ($Rc = 0.283$). Thus, while both communities could be considered resilient, they showed different strategies. Whereas *Trajectory 32* represents a resistant dynamic within the EDR, *Trajectory 33* represents a more variable system whose dynamics visit the borders of the EDR to eventually return towards the representative trajectory.

To support our evaluation of the ecological resilience of disturbed trajectories, we can calculate the dynamic dispersion (dDis) of the post-disturbance portion of the disturbed trajectories in relation to the trajectories in the EDR.

```{r dDis_post, echo = T}
# Species abundances in post-disturbance states of the disturbed trajectories
# The states after the release of the disturbance are identified by disturbed_states > 1
abun_post <- EDR_data$EDR3_disturbed$abundance[disturbed_states > 1] 
selcols <- names(EDR_data$EDR3$abundance)

# Species abundances in EDR3 and the post-disturbance states of disturbed trajectories
abun3_post <- rbind(EDR_data$EDR3$abundance, abun_post[, ..selcols])

# State dissimilarities in EDR3 and the post-disturbance states of disturbed trajectories
d3_post <- as.matrix(vegan::vegdist(x = abun3_post[, paste0("sp", 1:12)], method = "bray"))

# dDis of each disturbed trajectory
dDis_dist <- sapply(unique(abun_post$traj), function(idist){
  rm_disturbed <- unique(abun_post$traj[which(abun_post$traj != idist)])
  irm <- which(abun3_post$traj %in% rm_disturbed)
  dDis(d = d3_post[-irm, -irm], d.type = "dStates", 
       trajectories = abun3_post$traj[-irm], 
       states = abun3_post$state[-irm], 
       reference = as.character(idist))
})

```

The values of dDis confirm the resilience of *Trajectory 32* and show that, despite being able to recover after the disturbance, the dynamic represented by *Trajectory 33* is anomalous in relation to the other dynamics in the EDR.

```{r dDis_post_tb, echo = F}
knitr::kable(data.frame(disturbed_trajectory = 31:33, dDis = dDis_dist), digits = 3,
             row.names = F, col.names = c("Disturbed trajectories", "dDis"))
```

Finally, we can illustrate the responses of the three disturbed communities by representing their trajectories in relation to the reference EDR and its representative trajectory:

```{r plot_disturbed, fig.dim=c(7,6)}
# Plot EDR3 and its representative trajectories
plot(retra_ref, d = d, 
     trajectories = abun$traj, 
     states = abun$state, 
     traj.colors = c(rep("grey", 30), 2:4), 
     main = "Comparison of disturbed trajectories and EDR3")
legend("topleft", c("Representative trajectory", 
                    "Individual trajectories in EDR3",
                    "Trajectory 31",
                    "Trajectory 32",
                    "Trajectory 33"),
       lty = 1, col = c("black", "grey", 2:4), bty = "n")

```

## Acknowledgements

This project has received funding from the European Union’s Horizon 2020 research and innovation program under the Marie Sklodowska-Curie grant agreement No 891477 (RESET project).
